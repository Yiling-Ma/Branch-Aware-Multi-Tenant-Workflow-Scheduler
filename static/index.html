<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WSI AI Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/openseadragon/4.1.0/openseadragon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/openseadragon-svg-overlay@0.0.5/openseadragon-svg-overlay.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; 
            background: #0f111a; 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            color: #e0e0e0;
        }
        
        .navbar { 
            height: 60px; 
            background: #1a1d29; 
            display: flex; 
            align-items: center; 
            padding: 0 20px; 
            gap: 15px; 
            border-bottom: 1px solid #2f3342; 
        }
        
        .logo {
            font-weight: 600;
            font-size: 18px;
            color: #5c7cfa;
        }
        
        .search-box { 
            display: flex; 
            gap: 10px; 
            flex: 1;
            max-width: 500px;
        }
        
        input { 
            background: #0f111a; 
            border: 1px solid #2f3342; 
            color: white; 
            padding: 10px 15px; 
            border-radius: 6px; 
            outline: none;
            flex: 1;
        }
        
        input:focus {
            border-color: #5c7cfa;
        }
        
        button { 
            background: #5c7cfa; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            cursor: pointer; 
            font-weight: 500;
            border-radius: 6px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #4263eb;
        }
        
        button.secondary {
            background: #2f3342;
        }
        
        button.secondary:hover {
            background: #3d4150;
        }
        
        .toggle-btn.active {
            background-color: #2ecc71 !important; /* Green indicates active */
            color: white !important;
        }
        
        .icon-btn {
            background: #2f3342;
            color: #e0e0e0;
            border: 1px solid #2f3342;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 14px;
            gap: 6px;
        }
        
        .icon-btn:hover {
            background: #3d4150;
            border-color: #5c7cfa;
        }
        
        .icon-btn.active {
            background: #2ecc71;
            color: white;
        }
        
        .icon-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .tool-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        #viewer-container { 
            flex: 1; 
            position: relative; 
            background: #000;
        }
        
        #viewer { 
            width: 100%; 
            height: 100%; 
        }
        
        /* Fine cell contour styles */
        .cell-path {
            fill: rgba(0, 255, 255, 0.1);  /* Reduced fill opacity for cleaner visuals */
            stroke: #00ffff;
            stroke-width: 1px;  /* Thinner lines */
            vector-effect: non-scaling-stroke;
            opacity: 0.7;
        }
        
        .cell-path:hover {
            fill: rgba(0, 255, 255, 0.3);
            stroke: #ffffff;
            stroke-width: 1.2px;
        }
        
        /* Sidebar */
        .sidebar {
            position: absolute;
            top: 0;
            right: 0;
            width: 400px;
            height: 100%;
            background: rgba(26, 29, 41, 0.95);
            border-left: 1px solid #2f3342;
            z-index: 100;
            display: none;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .sidebar.active {
            display: flex;
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #2f3342;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sidebar-title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #a0a0a0;
            cursor: pointer;
            font-size: 24px;
            padding: 0;
            width: 30px;
            height: 30px;
        }
        
        .sidebar-content {
            padding: 20px;
            flex: 1;
        }
        
        /* Preview mode */
        .preview-mode {
            text-align: center;
        }
        
        .preview-image {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        /* Patch Overlay grid */
        .patch-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
        }
        
        .patch-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 6px;
            overflow: hidden;
            background: #0f111a;
            border: 1px solid #2f3342;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        
        .patch-item:hover {
            transform: scale(1.05);
            border-color: #5c7cfa;
        }
        
        .patch-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .patch-item .patch-actions {
            pointer-events: auto;
        }
        
        /* Test Scheduler Modal */
        .test-scheduler-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            overflow-y: auto;
        }
        
        .test-scheduler-modal.active {
            display: block;
        }
        
        .test-scheduler-content {
            background: #1a1d29;
            margin: 20px auto;
            padding: 30px;
            border-radius: 12px;
            max-width: 1400px;
            border: 1px solid #2f3342;
            color: #e0e0e0;
        }
        
        .test-scheduler-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #2f3342;
        }
        
        .test-scheduler-title {
            font-size: 24px;
            font-weight: 600;
            color: #5c7cfa;
        }
        
        .test-scheduler-actions {
            display: flex;
            gap: 10px;
        }
        
        .test-scheduler-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .test-scheduler-btn-primary {
            background: #2ecc71;
            color: white;
        }
        
        .test-scheduler-btn-primary:hover {
            background: #27ae60;
        }
        
        .test-scheduler-btn-warning {
            background: #f39c12;
            color: white;
        }
        
        .test-scheduler-btn-warning:hover {
            background: #e67e22;
        }
        
        .test-scheduler-btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .test-scheduler-btn-danger:hover {
            background: #c0392b;
        }
        
        .test-scheduler-btn-secondary {
            background: #2f3342;
            color: #e0e0e0;
        }
        
        .test-scheduler-btn-secondary:hover {
            background: #3d4150;
        }
        
        .test-scheduler-close {
            background: none;
            border: none;
            color: #a0a0a0;
            cursor: pointer;
            font-size: 28px;
            padding: 0;
            width: 35px;
            height: 35px;
            line-height: 35px;
        }
        
        .test-scheduler-close:hover {
            color: #e0e0e0;
        }
        
        .users-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .user-section {
            background: #0f111a;
            border: 1px solid #2f3342;
            border-radius: 8px;
            padding: 20px;
        }
        
        .user-header {
            font-size: 18px;
            font-weight: 600;
            color: #5c7cfa;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #2f3342;
        }
        
        .jobs-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .job-card {
            background: #1a1d29;
            border: 1px solid #2f3342;
            border-radius: 6px;
            padding: 15px;
            transition: all 0.2s;
        }
        
        .job-card:hover {
            border-color: #5c7cfa;
        }
        
        .job-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .job-id {
            font-size: 12px;
            color: #888;
            font-family: monospace;
        }
        
        .job-branch {
            font-size: 12px;
            color: #5c7cfa;
            font-weight: 500;
        }
        
        .job-status {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .job-status.PENDING {
            background: #f39c12;
            color: white;
        }
        
        .job-status.QUEUED {
            background: #3498db;
            color: white;
        }
        
        .job-status.RUNNING {
            background: #2ecc71;
            color: white;
        }
        
        .job-status.SUCCEEDED {
            background: #27ae60;
            color: white;
        }
        
        .job-status.FAILED {
            background: #e74c3c;
            color: white;
        }
        
        .job-status.CANCELLED {
            background: #95a5a6;
            color: white;
        }
        
        .job-progress {
            margin-top: 10px;
        }
        
        .job-progress-text {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        
        .job-progress-bar {
            width: 100%;
            height: 6px;
            background: #2f3342;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .job-progress-fill {
            height: 100%;
            background: #2ecc71;
            transition: width 0.3s;
        }
        
        .job-actions {
            margin-top: 10px;
            display: flex;
            gap: 8px;
        }
        
        .job-cancel-btn {
            padding: 6px 12px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .job-cancel-btn:hover {
            background: #c0392b;
        }
        
        .job-cancel-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .job-export-btn {
            padding: 6px 12px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .job-export-btn:hover {
            background: #229954;
        }
        
        .job-export-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .job-export-btn-group {
            display: flex;
            gap: 4px;
        }
        
        .job-log {
            margin-top: 10px;
            background: #0f111a;
            border: 1px solid #2f3342;
            border-radius: 4px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.6;
            display: none;
        }
        
        .job-log.active {
            display: block;
        }
        
        .job-log-line {
            color: #888;
            margin-bottom: 4px;
        }
        
        .job-log-line.info {
            color: #5c7cfa;
        }
        
        .job-log-line.success {
            color: #2ecc71;
        }
        
        .job-log-line.warning {
            color: #f39c12;
        }
        
        .job-log-line.error {
            color: #e74c3c;
        }
        
        .job-log-toggle {
            margin-top: 8px;
            padding: 6px 12px;
            background: #2f3342;
            color: #e0e0e0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .job-log-toggle:hover {
            background: #3d4150;
        }
        
        .job-log-toggle.active {
            background: #5c7cfa;
        }
        
        /* Job Selector */
        .job-selector-container {
            background: #0f111a;
            border: 1px solid #2f3342;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .job-selector-label {
            font-size: 14px;
            color: #888;
            margin-bottom: 10px;
        }
        
        .job-selector {
            width: 100%;
            padding: 10px;
            background: #1a1d29;
            border: 1px solid #2f3342;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            cursor: pointer;
        }
        
        .job-selector:focus {
            outline: none;
            border-color: #5c7cfa;
        }
        
        .job-selector option {
            background: #1a1d29;
            color: #e0e0e0;
        }
        
        /* Custom Job Form */
        .custom-job-form {
            background: #0f111a;
            border: 1px solid #2f3342;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-label {
            display: block;
            font-size: 13px;
            color: #888;
            margin-bottom: 5px;
        }
        
        .form-input, .form-select {
            width: 100%;
            padding: 10px;
            background: #1a1d29;
            border: 1px solid #2f3342;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
        }
        
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #5c7cfa;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .form-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        /* Image view modal */
        .image-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            cursor: pointer;
            overflow-y: auto;
        }
        
        .image-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 20px;
        }
        
        .image-modal-content {
            max-width: 90%;
            max-height: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: default;
        }
        
        .image-modal img {
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        
        .image-modal-close {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            background: rgba(0, 0, 0, 0.5);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .image-modal-close:hover {
            background: rgba(92, 124, 250, 0.8);
            color: white;
        }
        
        /* Modal navigation buttons (left/right arrows) */
        .modal-nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            user-select: none;
        }
        
        .modal-nav-btn:hover {
            background: rgba(92, 124, 250, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-50%) scale(1.1);
        }
        
        .modal-nav-btn:active {
            transform: translateY(-50%) scale(0.95);
        }
        
        .modal-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .modal-nav-prev {
            left: 20px;
        }
        
        .modal-nav-next {
            right: 20px;
        }
        
        /* Modal info panel */
        .modal-info-panel {
            background: #1a1d29;
            border-radius: 8px;
            padding: 20px;
            min-width: 600px;
            border: 1px solid #2f3342;
        }
        
        .modal-info-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .modal-info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .modal-info-label {
            color: #a0a0a0;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .modal-info-value {
            color: #e0e0e0;
            font-size: 16px;
            font-weight: 500;
        }
        
        .modal-actions-row {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .modal-action-btn {
            padding: 12px 40px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .modal-btn-correct {
            background: #2ecc71;
            color: white;
        }
        
        .modal-btn-correct:hover {
            background: #27ae60;
            transform: scale(1.05);
        }
        
        .modal-btn-incorrect {
            background: #e74c3c;
            color: white;
        }
        
        .modal-btn-incorrect:hover {
            background: #c0392b;
            transform: scale(1.05);
        }
        
        .modal-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .patch-info {
            position: absolute;
            bottom: 40px;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            padding: 5px 8px;
            font-size: 11px;
            color: white;
        }
        
        .patch-actions {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            gap: 5px;
            padding: 8px;
            justify-content: center;
            background: rgba(0,0,0,0.8);
        }
        
        .patch-btn {
            flex: 1;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .patch-btn-yes {
            background: #4caf50;
            color: white;
        }
        
        .patch-btn-yes:hover {
            background: #45a049;
        }
        
        .patch-btn-no {
            background: #f44336;
            color: white;
        }
        
        .patch-btn-no:hover {
            background: #da190b;
        }
        
        .patch-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .patch-item.patch-verified {
            border-color: #4caf50;
            border-width: 2px;
        }
        
        .patch-item.patch-rejected {
            border-color: #f44336;
            border-width: 2px;
        }
        
        .patch-item.patch-selected {
            border-color: #5c7cfa;
            border-width: 2px;
            box-shadow: 0 0 10px rgba(92, 124, 250, 0.5);
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #a0a0a0;
        }
        
        .status-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 50;
        }
        
        /* Quality Check real-time verification panel styles */
        .quality-check-panel {
            margin-top: 20px;
            padding: 15px;
            background: #1a1d29;
            border-radius: 8px;
            border: 1px solid #2f3342;
        }
        
        .quality-check-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 14px;
            color: #e0e0e0;
        }
        
        .quality-check-image-container {
            width: 100%;
            aspect-ratio: 1;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }
        
        .quality-check-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .quality-check-btn {
            width: 100%;
            background: #2ecc71;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .quality-check-btn:hover {
            background: #27ae60;
        }
        
        .quality-check-btn:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        .quality-check-info {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
            text-align: center;
        }
        
        .quality-check-loading {
            color: #5c7cfa;
            font-size: 13px;
        }
        
        /* File Manager Styles */
        .file-upload-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #0f111a;
            border-radius: 8px;
            border: 1px solid #2f3342;
        }
        
        .file-list-section {
            margin-bottom: 30px;
        }
        
        .file-list-title {
            font-size: 18px;
            font-weight: 600;
            color: #5c7cfa;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #2f3342;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: #0f111a;
            border: 1px solid #2f3342;
            border-radius: 6px;
            margin-bottom: 8px;
            transition: all 0.2s;
        }
        
        .file-item:hover {
            background: #1a1d29;
            border-color: #5c7cfa;
        }
        
        .file-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .file-name {
            font-weight: 500;
            color: #e0e0e0;
        }
        
        .file-meta {
            font-size: 11px;
            color: #888;
        }
        
        .file-actions {
            display: flex;
            gap: 8px;
        }
        
        .file-action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .file-action-btn-download {
            background: #3498db;
            color: white;
        }
        
        .file-action-btn-download:hover {
            background: #2980b9;
        }
        
        .file-action-btn-delete {
            background: #e74c3c;
            color: white;
        }
        
        .file-action-btn-delete:hover {
            background: #c0392b;
        }
        
        .file-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #0f111a;
            border-radius: 8px;
            border: 1px solid #2f3342;
        }
        
        .file-stat-item {
            flex: 1;
            text-align: center;
        }
        
        .file-stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #5c7cfa;
        }
        
        .file-stat-label {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
        }
    </style>
</head>
<body>
<div class="navbar">
    <div class="logo">WSI AI Viewer</div>
    <div class="search-box">
        <input type="text" id="jobIdInput" placeholder="Enter Job UUID..." 
               onkeypress="if(event.key==='Enter') loadDeepZoom()">
        <button onclick="loadDeepZoom()">Load Slide</button>
        <button class="secondary" onclick="toggleSidebar('preview')">Preview</button>
        <button class="secondary" onclick="toggleSidebar('patches')">Quality Check</button>
        <button class="secondary" onclick="showTestSchedulerModal()" style="background: #9b59b6;">Test Scheduler</button>
        <button class="secondary" onclick="showFileManagerModal()" style="background: #e67e22;">File Manager</button>
        <button class="secondary" onclick="window.open('/static/metrics.html', '_blank')" style="background: #16a085;">Metrics</button>
        <div class="tool-group" style="margin-left: 10px;">
            <button class="icon-btn" id="maskBtn" title="Show Tissue Mask" onclick="toggleTissueMask(this)">
                <span class="material-icons" style="font-size: 18px; margin-right: 6px;">blur_on</span>
                <span>Tissue Mask</span>
            </button>
        </div>
        <button class="secondary" onclick="testConnection()" style="font-size: 11px; padding: 8px 12px;">Test</button>
    </div>
</div>

<div id="viewer-container">
    <div id="viewer"></div>
    <div id="status-overlay" class="status-bar">Waiting to load...</div>
    
    <!-- Sidebar -->
    <div id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title" id="sidebarTitle">Preview</div>
            <button class="close-btn" onclick="closeSidebar()">√ó</button>
        </div>
        <div class="sidebar-content" id="sidebarContent"></div>
    </div>
    
    <!-- Image view modal -->
    <div id="imageModal" class="image-modal" onclick="closeImageModal()">
        <div class="image-modal-content" onclick="event.stopPropagation();">
            <span class="image-modal-close" onclick="event.stopPropagation(); closeImageModal();">√ó</span>
            <!-- Left/right arrow buttons -->
            <button id="modalPrevBtn" class="modal-nav-btn modal-nav-prev" onclick="event.stopPropagation(); navigatePatch(-1);" title="Previous patch (‚Üê)">
                ‚Üê
            </button>
            <button id="modalNextBtn" class="modal-nav-btn modal-nav-next" onclick="event.stopPropagation(); navigatePatch(1);" title="Next patch (‚Üí)">
                ‚Üí
            </button>
            <img id="modalImage" src="" alt="Full size patch" onclick="event.stopPropagation();">
            <div id="modalInfoPanel" class="modal-info-panel">
                <div class="modal-info-row">
                    <div class="modal-info-item">
                        <span class="modal-info-label">Patch:</span>
                        <span id="modalPatchCoords" class="modal-info-value">-</span>
                    </div>
                    <div class="modal-info-item">
                        <span class="modal-info-label">Segmentation:</span>
                        <span id="modalCellscount" class="modal-info-value">-</span>
                    </div>
                    <div class="modal-info-item">
                        <span class="modal-info-label">Cell ID:</span>
                        <span id="modalCellId" class="modal-info-value">-</span>
                    </div>
                    <div class="modal-info-item">
                        <span class="modal-info-label">Position:</span>
                        <span id="modalPosition" class="modal-info-value">-</span>
                    </div>
                </div>
                <div id="modalSegmentationDetails" class="modal-segmentation-details" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #2f3342; display: none;">
                    <div style="font-size: 12px; color: #888; line-height: 1.8;">
                        <div>All detected: <span id="modalAllDetected" style="color: #e0e0e0;">-</span></div>
                        <div>Displayed: <span id="modalDisplayed" style="color: #00ffff;">-</span></div>
                        <div>Filtered: <span id="modalFiltered" style="color: #888;">-</span></div>
                    </div>
                </div>
                <div class="modal-actions-row">
                    <button id="modalCorrectBtn" class="modal-action-btn modal-btn-correct" onclick="event.stopPropagation(); markPatchCorrect();">
                        Correct
                    </button>
                    <button id="modalIncorrectBtn" class="modal-action-btn modal-btn-incorrect" onclick="event.stopPropagation(); markPatchIncorrect();">
                        Incorrect
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- File Manager Modal -->
<div id="fileManagerModal" class="test-scheduler-modal">
    <div class="test-scheduler-content">
        <div class="test-scheduler-header">
            <div class="test-scheduler-title">File Manager</div>
            <div class="test-scheduler-actions">
                <button class="test-scheduler-btn test-scheduler-btn-primary" onclick="refreshFileManager()">Refresh</button>
                <button class="test-scheduler-close" onclick="closeFileManagerModal()">√ó</button>
            </div>
        </div>
        
        <!-- Create New User Section -->
        <div class="file-upload-section" style="margin-bottom: 20px; padding: 20px; background: #0f111a; border-radius: 8px; border: 1px solid #2f3342;">
            <h3 style="margin-top: 0; color: #5c7cfa;">üë§ Create New User</h3>
            <div style="display: flex; gap: 10px; align-items: flex-end;">
                <div style="flex: 1;">
                    <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #888;">Username:</label>
                    <input type="text" id="newUserNameInput" class="form-input" placeholder="e.g., Yiling" style="width: 100%;">
                </div>
                <button class="test-scheduler-btn test-scheduler-btn-primary" onclick="createNewUser()">‚ûï Create User</button>
            </div>
            <div id="newUserStatus" style="margin-top: 10px; font-size: 12px; color: #888;"></div>
        </div>
        
        <!-- User Selection -->
        <div class="job-selector-container" style="margin-bottom: 20px;">
            <div class="job-selector-label">Select User:</div>
            <select id="fileManagerUserSelector" class="job-selector" onchange="loadUserFiles()">
                <option value="">-- Select a user --</option>
            </select>
            <div id="selectedUserInfo" style="margin-top: 10px; padding: 10px; background: #0f111a; border-radius: 6px; border: 1px solid #2f3342; display: none;">
                <div style="font-size: 12px; color: #888; margin-bottom: 5px;">Your User ID (use this in Custom Job):</div>
                <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 10px;">
                    <code id="selectedUserId" style="flex: 1; padding: 8px; background: #1a1d29; border: 1px solid #2f3342; border-radius: 4px; color: #5c7cfa; font-size: 11px; word-break: break-all;"></code>
                    <button class="test-scheduler-btn test-scheduler-btn-secondary" onclick="copyUserId()" style="padding: 8px 12px; font-size: 11px;">Copy</button>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button class="test-scheduler-btn test-scheduler-btn-danger" onclick="deleteSelectedUser()" style="padding: 8px 12px; font-size: 11px; flex: 1;">Delete User</button>
                </div>
            </div>
        </div>
        
        <!-- File Upload Section -->
        <div class="file-upload-section" style="margin-bottom: 30px; padding: 20px; background: #0f111a; border-radius: 8px; border: 1px solid #2f3342;">
            <h3 style="margin-top: 0; color: #5c7cfa;">Upload Input File</h3>
            <input type="file" id="fileUploadInput" style="margin-bottom: 10px; color: #e0e0e0;">
            <button class="test-scheduler-btn test-scheduler-btn-primary" onclick="uploadUserFile()">Upload</button>
            <div id="uploadStatus" style="margin-top: 10px; font-size: 12px; color: #888;"></div>
        </div>
        
        <!-- Files Display -->
        <div id="fileManagerContent">
            <div style="text-align: center; padding: 40px; color: #888;">
                Please select a user to view their files
            </div>
        </div>
    </div>
</div>

<!-- Test Scheduler Modal -->
<div id="testSchedulerModal" class="test-scheduler-modal">
    <div class="test-scheduler-content">
        <div class="test-scheduler-header">
            <div class="test-scheduler-title">Test Scheduler</div>
            <div class="test-scheduler-actions">
                <button class="test-scheduler-btn test-scheduler-btn-primary" onclick="showCustomJobForm()">Create Custom Job</button>
                <button class="test-scheduler-btn test-scheduler-btn-primary" onclick="createTestJobs()">Create Test Jobs (Auto)</button>
                <button class="test-scheduler-btn test-scheduler-btn-warning" onclick="cancelAllTestJobs()">Stop All Jobs</button>
                <button class="test-scheduler-btn test-scheduler-btn-danger" onclick="clearAllTestJobs()">Clear All</button>
                <button class="test-scheduler-close" onclick="closeTestSchedulerModal()">√ó</button>
            </div>
        </div>
        
        <!-- Job Selector for Load Slide -->
        <div class="job-selector-container">
            <div class="job-selector-label">Select Job to Load:</div>
            <select id="jobSelector" class="job-selector" onchange="loadSelectedJob()">
                <option value="">-- Select a completed job --</option>
            </select>
        </div>
        
        <!-- Custom Job Form -->
        <div id="customJobForm" class="custom-job-form" style="display: none;">
            <h3 style="margin-top: 0; color: #5c7cfa;">Create Custom Job</h3>
            <div class="form-group">
                <label class="form-label">User ID (from File Manager)</label>
                <input type="text" id="customJobUserId" class="form-input" placeholder="Paste your User ID here (e.g., 123e4567-e89b-12d3-a456-426614174000)" onchange="onCustomJobUserIdChange()">
                <div style="font-size: 11px; color: #888; margin-top: 5px;">
                    Tip: Create a user in File Manager first, then copy the User ID and paste it here. This will load your uploaded files.
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Branch ID</label>
                    <input type="text" id="customJobBranch" class="form-input" placeholder="e.g., branch_A" value="branch_A">
                </div>
                <div class="form-group">
                    <label class="form-label">Job Type</label>
                    <select id="customJobType" class="form-select">
                        <option value="cell_segmentation">Cell Segmentation</option>
                        <option value="tissue_mask">Tissue Mask</option>
                    </select>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">Job Name</label>
                <input type="text" id="customJobName" class="form-input" placeholder="e.g., My_Segmentation_Job">
            </div>
            <div class="form-group">
                <label class="form-label">Image Path (Select from File Manager)</label>
                <select id="customJobImageFileSelect" class="form-select" onchange="selectImageFromFileManager()" required>
                    <option value="">-- Select from uploaded files --</option>
                </select>
                <input type="hidden" id="customJobImagePath" value="">
                <div style="font-size: 11px; color: #888; margin-top: 5px;">
                    Please select a file from File Manager. Upload files in File Manager first if needed.
                </div>
            </div>
            <div class="form-actions">
                <button class="test-scheduler-btn test-scheduler-btn-primary" onclick="submitCustomJob()">Create Job</button>
                <button class="test-scheduler-btn test-scheduler-btn-secondary" onclick="hideCustomJobForm()">Cancel</button>
            </div>
        </div>
        
        <div id="testSchedulerUsersContainer" class="users-container">
            <!-- Users and jobs will be dynamically inserted here -->
        </div>
    </div>
</div>

<script>
    let viewer = null;
    let overlay = null;
    let currentJobId = null;
    let currentJobData = null;
    let currentJobResult = null;

    function updateStatus(msg) {
        const statusEl = document.getElementById('status-overlay');
        if (statusEl) statusEl.innerText = msg;
    }

    async function loadDeepZoom() {
        const jobId = document.getElementById('jobIdInput').value.trim();
        if(!jobId) {
            alert("Please enter Job ID");
            updateStatus("Please enter Job ID");
            return;
        }
        
        // Check if OpenSeadragon is loaded
        if (typeof OpenSeadragon === 'undefined') {
            updateStatus("OpenSeadragon library not loaded. Please refresh the page.");
            console.error("OpenSeadragon is not defined");
            alert("OpenSeadragon library not loaded. Please check your internet connection and refresh the page.");
            return;
        }
        
        currentJobId = jobId;
        updateStatus("Connecting to server...");
        console.log("Loading job:", jobId);
        
        try {
            // Directly fetch single task data (more reliable)
            updateStatus("Fetching job data...");
            const jobResponse = await fetch(`http://127.0.0.1:8000/jobs/${jobId}`);
            
            if (!jobResponse.ok) {
                if (jobResponse.status === 404) {
                    updateStatus(`Job not found: ${jobId}`);
                    const errorMsg = `Job not found: ${jobId}\n\nPossible reasons:\n1. The Job ID is incorrect\n2. The job hasn't been created yet\n3. The job was deleted\n\nTip: Click the "Test" button to see available Job IDs in the database.`;
                    alert(errorMsg);
                    console.error("Job not found. Available actions:");
                    console.log("1. Click 'Test' button to see available jobs");
                    console.log("2. Submit a new workflow to create a job");
                    console.log("3. Check if the backend server is running");
                } else if (jobResponse.status === 0 || jobResponse.status === 500) {
                    updateStatus(`Server error. Is the backend running?`);
                    alert(`Cannot connect to server.\n\nPlease check:\n1. Backend server is running (uvicorn app.main:app --reload)\n2. Server is accessible at http://127.0.0.1:8000\n3. Check terminal for error messages`);
                } else {
                    updateStatus(`Error loading job: ${jobResponse.statusText}`);
                    alert(`Error loading job: ${jobResponse.statusText} (Status: ${jobResponse.status})\n\nPlease check the backend server logs for details.`);
                }
                console.error("Job fetch failed:", jobResponse.status, jobResponse.statusText);
                return;
            }
            
            updateStatus("Parsing job data...");
            const job = await jobResponse.json();
            console.log("Job data received:", job);
            
            if (job.status !== "SUCCEEDED") {
                updateStatus(`Job not ready (status: ${job.status})`);
                alert(`Job is not ready yet.\n\ncurrent status: ${job.status}\n\nPlease wait for the job to complete.`);
                return;
            }
            
            currentJobData = job;
            
            // Check if result_metadata exists
            if (!job.result_metadata) {
                updateStatus(`Job has no result metadata`);
                console.error("Job result_metadata is missing:", job);
                alert(`Job has no result metadata.\n\nJob ID: ${jobId}\nStatus: ${job.status}\n\nThis might be a tissue mask job or the job didn't save results properly.`);
                return;
            }
            
            let res;
            try {
                res = JSON.parse(job.result_metadata);
                currentJobResult = res;
                console.log("Parsed result metadata:", res);
            } catch (e) {
                updateStatus(`failed to parse result metadata: ${e.message}`);
                console.error("failed to parse result_metadata:", e, job.result_metadata);
                alert(`failed to parse result metadata: ${e.message}\n\nThis might indicate corrupted data.`);
                return;
            }
            
            // Handle different results based on job_type
            const jobType = res.job_type || job.job_type || "cell_segmentation";
            console.log("Job loaded:", { jobId, jobType, status: job.status });
            
            // Initialize Viewer
            if (viewer) {
                try {
                    viewer.destroy();
                } catch (e) {
                    console.warn("Error destroying previous viewer:", e);
                }
            }
            
            const dziUrl = `http://127.0.0.1:8000/dzi/${jobId}.dzi`;
            console.log("Loading DZI from:", dziUrl);
            updateStatus("Initializing viewer...");
            
            try {
                viewer = OpenSeadragon({
                    id: "viewer",
                    prefixUrl: "https://cdnjs.cloudflare.com/ajax/libs/openseadragon/4.1.0/images/",
                    tileSources: dziUrl,
                    animationTime: 0,
                    showNavigationControl: true
                });
                
                // Add error handling
                viewer.addHandler('open-failed', function(event) {
                    console.error("OpenSeadragon open failed:", event);
                    const errorMsg = event.message || event.error || 'Unknown error';
                    updateStatus(`failed to load tiles: ${errorMsg}`);
                    alert(`failed to load image tiles.\n\nError: ${errorMsg}\n\nPlease check:\n1. DZI API endpoint is accessible: http://127.0.0.1:8000/dzi/${jobId}.dzi\n2. Image file exists: ./data/CMU-1.svs\n3. Backend server is running properly`);
                });
                
                viewer.addHandler('tile-load-failed', function(event) {
                    console.warn("Tile load failed:", event);
                    updateStatus(`Some tiles failed to load. Check console for details.`);
                });
                
                // Add timeout handling
                setTimeout(() => {
                    if (viewer && !viewer.isOpen()) {
                        updateStatus(`Timeout: Image failed to load after 30 seconds`);
                        alert(`Image loading timeout.\n\nPlease check:\n1. Backend server is running\n2. DZI endpoint is accessible\n3. Image file exists\n\nTry refreshing the page.`);
                    }
                }, 30000);
                
            } catch (e) {
                updateStatus(`failed to initialize viewer: ${e.message}`);
                console.error("OpenSeadragon initialization error:", e);
                return;
            }
            
            updateStatus("Loading tiles...");
            
            // Render different results based on task type
            if (jobType === "tissue_mask" || jobType === "tissue_mask_generation" || jobType === "mask") {
                // Task type 2: Tissue mask
                viewer.addHandler('open', function() {
                    try {
                        const tiledImage = viewer.world.getItemAt(0);
                        const size = tiledImage.getContentSize();
                        const w = size.x;
                        const h = size.y;
                        
                        // Display mask overlay (if mask URL exists)
                        if (res.mask_url) {
                            updateStatus(`Tissue mask generated | Tissue tiles: ${res.tissue_tiles}/${res.total_tiles}`);
                        } else {
                            updateStatus(`Tissue mask task completed | Tissue tiles: ${res.tissue_tiles}/${res.total_tiles}`);
                        }
                    } catch (e) {
                        console.error(e);
                        updateStatus("Error rendering mask");
                    }
                });
            } else {
                // Task type 1: Cell segmentation (default)
                // Check data
                if (!res.cells || res.cells.length === 0) {
                    updateStatus("No cells found");
                    return;
                }
                
                if (!res.cells[0].poly) {
                    updateStatus("Invalid data format");
                    return;
                }
                
                // Render contours
                viewer.addHandler('open', function() {
                    try {
                    const tiledImage = viewer.world.getItemAt(0);
                    const size = tiledImage.getContentSize();
                    const w = size.x;
                    const h = size.y;
                    
                    console.log(`Image size: ${w}x${h}`);
                    
                    // Initialize Overlay - use simpler direct method
                    const viewerElement = document.getElementById('viewer');
                    
                    // Remove old overlay (if exists)
                    const oldOverlay = viewerElement.querySelector('svg.contour-overlay');
                    if (oldOverlay) oldOverlay.remove();
                    
                    const svgNS = "http://www.w3.org/2000/svg";
                    const svgElement = document.createElementNS(svgNS, "svg");
                    svgElement.setAttribute("xmlns", svgNS);
                    svgElement.setAttribute("class", "contour-overlay");
                    svgElement.setAttribute("viewBox", `0 0 ${w} ${h}`);
                    svgElement.setAttribute("preserveAspectRatio", "none");
                    svgElement.style.position = "absolute";
                    svgElement.style.pointerEvents = "none";
                    svgElement.style.zIndex = "1000";
                    svgElement.style.overflow = "visible";
                    viewerElement.appendChild(svgElement);
                    
                    // Sync SVG to viewport - ensure SVG covers entire image
                    const syncSVGToViewport = () => {
                        const viewport = viewer.viewport;
                        const tiledImage = viewer.world.getItemAt(0);
                        if (!tiledImage) return;
                        
                        const imageBounds = tiledImage.getBounds();
                        const viewportBounds = viewport.getBounds();
                        const containerSize = viewport.getContainerSize();
                        
                        // Calculate image display position and size in container
                        const scaleX = containerSize.x / viewportBounds.width;
                        const scaleY = containerSize.y / viewportBounds.height;
                        
                        const imageDisplayX = (imageBounds.x - viewportBounds.x) * scaleX;
                        const imageDisplayY = (imageBounds.y - viewportBounds.y) * scaleY;
                        const imageDisplayWidth = imageBounds.width * scaleX;
                        const imageDisplayHeight = imageBounds.height * scaleY;
                        
                        svgElement.style.left = imageDisplayX + "px";
                        svgElement.style.top = imageDisplayY + "px";
                        svgElement.style.width = imageDisplayWidth + "px";
                        svgElement.style.height = imageDisplayHeight + "px";
                        
                        // update viewBox to match image dimensions
                        svgElement.setAttribute("viewBox", `0 0 ${w} ${h}`);
                    };
                    
                    viewer.addHandler('animation', syncSVGToViewport);
                    viewer.addHandler('resize', syncSVGToViewport);
                    viewer.addHandler('viewport-change', syncSVGToViewport);
                    syncSVGToViewport();
                    
                    overlay = { node: () => svgElement, resize: syncSVGToViewport };
                    
                    const d3Svg = d3.select(svgElement);
                    d3Svg.attr("viewBox", `0 0 ${w} ${h}`)
                         .attr("preserveAspectRatio", "none")
                         .style("pointer-events", "none");
                    
                    // Draw contours
                    const validCells = res.cells.filter(cell => 
                        cell.poly && Array.isArray(cell.poly) && cell.poly.length >= 3
                    );
                    
                    console.log(`Rendering ${validCells.length} cell contours on Deep Zoom view`);
                    console.log(`Image dimensions: ${w}x${h}`);
                    if (validCells.length > 0) {
                        const sampleCell = validCells[0];
                        const samplePoly = sampleCell.poly[0];
                        console.log(`Sample cell coordinate: [${samplePoly[0]}, ${samplePoly[1]}]`);
                    }
                    
                    // If cell count is too large, perform sparse sampling (consistent with preview)
                    let displayCells = validCells;
                    if (res.sampling_info && validCells.length > 5000) {
                        const step = res.sampling_info.sampling_step || Math.ceil(validCells.length / 5000);
                        displayCells = validCells.filter((cell, index) => index % step === 0);
                        console.log(`Sparse sampling: displaying ${displayCells.length} of ${validCells.length} cells`);
                    }
                    
                    const lineGen = d3.line()
                        .x(d => d[0])
                        .y(d => d[1]);
                    
                    // Clear previous paths
                    d3Svg.selectAll("path.cell-path").remove();
                    
                    // Draw contour paths
                    const paths = d3Svg.selectAll("path.cell-path")
                        .data(displayCells, (d, i) => i);
                    
                    paths.enter()
                        .append("path")
                        .attr("d", d => {
                            if (!d.poly || d.poly.length < 3) return "";
                            return lineGen(d.poly);
                        })
                        .attr("class", "cell-path")
                        .style("fill", "rgba(0, 255, 255, 0.1)")  /* Reduced fill opacity for cleaner visuals */
                        .style("stroke", "#00ffff")
                        .style("stroke-width", "1px")  /* Thinner lines */
                        .style("vector-effect", "non-scaling-stroke")
                        .style("opacity", "0.7");
                    
                    // Immediately call resize to ensure SVG syncs correctly
                    syncSVGToViewport();
                    
                    console.log(`Successfully rendered ${displayCells.length} cell contours`);
                    
                    // Display cell count information (including sparse sampling info)
                    let statusMsg = `Ready. ${validCells.length} cells detected.`;
                    if (res.sampling_info) {
                        statusMsg = `Ready. Large cell count (${res.sampling_info.total_cells}), preview sparse sampling displays ${res.sampling_info.displayed_cells} cells`;
                    } else if (res.total_cells) {
                        statusMsg = `Ready. ${res.total_cells} cells detected.`;
                    }
                    updateStatus(statusMsg);
                    } catch (e) {
                        console.error(e);
                        updateStatus("Error rendering contours");
                    }
                });
                
                viewer.addHandler('open-failed', (e) => {
                    updateStatus("failed to load tiles");
                });
            } // Close else branch
            
        } catch (e) {
            console.error(e);
            updateStatus("Error: " + e.message);
        }
    }
    
    async function toggleSidebar(mode) {
        const sidebar = document.getElementById('sidebar');
        const title = document.getElementById('sidebarTitle');
        const content = document.getElementById('sidebarContent');
        
        if (sidebar.classList.contains('active') && sidebar.dataset.mode === mode) {
            closeSidebar();
            return;
        }
        
        // Check Quality Check (patches) whetherrequires cell_segmentation
        if (mode === 'patches') {
            if (!currentJobId) {
                alert('Please load a job first');
                return;
            }
            
            try {
                // Check same branch has cell_segmentation job
                const branchResponse = await fetch(`http://127.0.0.1:8000/jobs/${currentJobId}/branch-jobs`);
                if (branchResponse.ok) {
                    const branchData = await branchResponse.json();
                    if (!branchData.has_cell_segmentation) {
                        alert(`No cell segmentation job found in this branch.\n\nBranch: ${branchData.branch_id}\ncurrent job type: ${branchData.current_job_type}\n\nPlease run a cell segmentation job in this branch first.`);
                        return;
                    }
                }
            } catch (e) {
                console.error('Error checking branch jobs:', e);
                // If check failed,continue execution (backward compatible)))
            }
        }
        
        sidebar.classList.add('active');
        sidebar.dataset.mode = mode;
        
        if (mode === 'preview') {
            title.innerText = 'Preview Image';
            loadPreview(content);
        } else if (mode === 'patches') {
            title.innerText = 'Segmentation Verification';
            content.innerHTML = `
                <div style="padding: 20px;">
                    <!-- Title and statistics -->
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #e0e0e0; margin-bottom: 10px;">Candidate Pool</h3>
                        <div style="color: #a0a0a0; font-size: 14px;">
                            <span id="candidatePoolInfo">Loading...</span>
                        </div>
                        <div style="color: #888; font-size: 12px; margin-top: 5px;">
                            Use <kbd style="background: #2f3342; padding: 2px 6px; border-radius: 3px;">Y</kbd> / <kbd style="background: #2f3342; padding: 2px 6px; border-radius: 3px;">N</kbd> keys for quick labeling
                        </div>
                    </div>
                    
                    <!-- Patches grid (15 per page, 3 rows x 5 columns) -->
                    <div id="patchesContainer" class="patch-grid"></div>
                    
                    <!-- Pagination controls -->
                    <div style="margin-top: 20px; display: flex; justify-content: center; align-items: center; gap: 20px;">
                        <button onclick="previousPage()" id="prevPageBtn" 
                                style="width: 40px; height: 40px; border-radius: 50%; background: #2f3342; border: 1px solid #5c7cfa; color: #5c7cfa; cursor: pointer; font-size: 20px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;"
                                onmouseover="this.style.background='#5c7cfa'; this.style.color='white';"
                                onmouseout="this.style.background='#2f3342'; this.style.color='#5c7cfa';">
                            ‚Üê
                        </button>
                        <div style="color: #a0a0a0; font-size: 13px;">
                            <span id="currentPage">1</span> / <span id="totalPages">1</span>
                        </div>
                        <button onclick="nextPage()" id="nextPageBtn"
                                style="width: 40px; height: 40px; border-radius: 50%; background: #2f3342; border: 1px solid #5c7cfa; color: #5c7cfa; cursor: pointer; font-size: 20px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;"
                                onmouseover="this.style.background='#5c7cfa'; this.style.color='white';"
                                onmouseout="this.style.background='#2f3342'; this.style.color='#5c7cfa';">
                            ‚Üí
                        </button>
                    </div>
                    
                    <!-- Accuracy statistics -->
                    <div id="accuracyPanel" style="margin-top: 30px; padding: 15px; background: #1a1d29; border-radius: 8px; border: 1px solid #2f3342; display: none;">
                        <h4 style="color: #e0e0e0; margin-bottom: 10px;">Segmentation Accuracy</h4>
                        <div id="accuracyContent"></div>
                    </div>
                </div>
            `;
            // Initialize patches display
            setTimeout(() => {
                if (typeof window.loadAllPatches === 'function') {
                    window.loadAllPatches();
                } else {
                    console.error('loadAllPatches function not found');
                }
            }, 100);
        }
    }
    
    function closeSidebar() {
        document.getElementById('sidebar').classList.remove('active');
    }
    
    async function loadPreview(container) {
        if (!currentJobData) {
            container.innerHTML = '<div class="loading">Please load a job first</div>';
            return;
        }
        
        try {
            const res = currentJobResult || JSON.parse(currentJobData.result_metadata);
            if (!currentJobResult) {
                currentJobResult = res;
            }
            const jobType = res.job_type || currentJobData.job_type || "cell_segmentation";
            
            // If current job is tissue mask,Check whether there is cell segmentation job
            if (jobType === "tissue_mask" || jobType === "tissue_mask_generation" || jobType === "mask") {
                // Check same branch whether there is cell segmentation job
                if (currentJobId) {
                    try {
                        const branchResponse = await fetch(`http://127.0.0.1:8000/jobs/${currentJobId}/branch-jobs`);
                        if (branchResponse.ok) {
                            const branchData = await branchResponse.json();
                            if (!branchData.has_cell_segmentation) {
                                // No cell segmentation job,show alert
                                container.innerHTML = `
                                    <div class="preview-mode" style="padding: 40px 20px; text-align: center;">
                                        <div style="font-size: 48px; margin-bottom: 20px;"></div>
                                        <h3 style="color: #e0e0e0; margin-bottom: 15px;">No Cell Segmentation Preview</h3>
                                        <p style="color: #a0a0a0; line-height: 1.6; margin-bottom: 20px;">
                                            Preview is only available for cell segmentation tasks.<br>
                                            This branch only has tissue mask task.
                                        </p>
                                        <p style="color: #5c7cfa; font-size: 14px;">
                                            <strong>Tip:</strong> Click the <span style="background: #2f3342; padding: 4px 8px; border-radius: 4px; margin: 0 4px;">Tissue Mask</span> button above to view the tissue mask overlay
                                        </p>
                                        <div style="margin-top: 25px; padding: 15px; background: #1a1d29; border-radius: 8px; text-align: left;">
                                            <div style="color: #888; font-size: 12px; margin-bottom: 8px;">CURRENT JOB INFO:</div>
                                            <div style="color: #a0a0a0; font-size: 14px;">
                                                Branch: <span style="color: #5c7cfa;">${branchData.branch_id}</span><br>
                                                Job Type: <span style="color: #5c7cfa;">${branchData.current_job_type}</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                                return;
                            }
                        }
                    } catch (e) {
                        console.error('Error checking branch jobs:', e);
                        // If check failed,continue to display (backward compatible))
                    }
                }
                
                // If there is cell segmentation job, but current loaded is tissue mask job
                // Still alert user
                container.innerHTML = `
                    <div class="preview-mode" style="padding: 40px 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 20px;"></div>
                        <h3 style="color: #e0e0e0; margin-bottom: 15px;">Tissue Mask Job Loaded</h3>
                        <p style="color: #a0a0a0; line-height: 1.6; margin-bottom: 20px;">
                            Preview is only available for cell segmentation tasks.<br>
                            Please load a cell segmentation job to view preview.
                        </p>
                        <p style="color: #5c7cfa; font-size: 14px;">
                            <strong>Tip:</strong> Click the <span style="background: #2f3342; padding: 4px 8px; border-radius: 4px; margin: 0 4px;">Tissue Mask</span> button above to view the tissue mask overlay
                        </p>
                    </div>
                `;
                return;
            }
            
            // Cell segmentation task - normally display preview
            const previewUrl = `http://127.0.0.1:8000${res.preview_url}`;
            let cellInfo = `Total cells: ${res.total_cells || 'N/A'}`;
            if (res.sampling_info) {
                cellInfo = `
                    <p style="margin-top: 15px; color: #a0a0a0;">
                        <strong>Cell Statistics:</strong><br>
                        Total cells: ${res.sampling_info.total_cells.toLocaleString()}<br>
                        <span style="color: #5c7cfa;">Preview sparse sampling display: ${res.sampling_info.displayed_cells.toLocaleString()} cells</span><br>
                        <span style="font-size: 12px; color: #888;">(Sampling step: ${res.sampling_info.sampling_step})</span>
                    </p>
                `;
            } else {
                cellInfo = `<p style="margin-top: 15px; color: #a0a0a0;">Total cells: ${res.total_cells || 'N/A'}</p>`;
            }
            
            container.innerHTML = `
                <div class="preview-mode">
                    <img src="${previewUrl}" alt="Preview" class="preview-image" onerror="this.parentElement.innerHTML='<div class=\\'loading\\'>Preview not available</div>'">
                    ${cellInfo}
                </div>
            `;
        } catch (e) {
            console.error('Error loading preview:', e);
            container.innerHTML = '<div class="loading">Error loading preview</div>';
        }
    }
    
    // Store all patches data
    window.allPatchesData = window.allPatchesData || [];
    window.currentPage = window.currentPage || 1;
    window.patchesPerPage = 15;
    window.currentPatchIndex = window.currentPatchIndex || 0; // currently selected patch index (for keyboard shortcuts)
    
    // Load all patches (global function)
    window.loadAllPatches = async function() {
        console.log('loadAllPatches called');
        
        // Check whether job is loaded
        if (!currentJobId) {
            console.error('No job loaded. Cannot load patches.');
            const container = document.getElementById('patchesContainer');
            if (container) {
                container.innerHTML = `<div style="color: #ff6b6b; text-align: center; padding: 20px;">Please load a job first</div>`;
            }
            return;
        }

        window.currentPage = 1;
        window.currentPatchIndex = 0;
        
        try {
            // Pass job_id parameter
            const response = await fetch(`http://127.0.0.1:8000/debug/all-patches?job_id=${currentJobId}`);
            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }
            const data = await response.json();
            console.log('Patches loaded:', data.total_patches, 'patches', 'from image:', data.image_path);
            
            // Show whether background patches are filtered
            if (data.filtered_by_tissue_mask) {
                console.log('Background patches filtered by tissue mask');
            } else {
                console.log('No tissue mask filtering applied (all patches included)');
            }
            
            const qualityChecks = (currentJobResult && Array.isArray(currentJobResult.quality_checks))
                ? currentJobResult.quality_checks
                : [];
            const qualityMap = {};
            qualityChecks.forEach((qc) => {
                const key = `${qc.x}_${qc.y}`;
                qualityMap[key] = qc;
            });
            
            window.allPatchesData = data.patches.map((patch, idx) => {
                const key = `${patch.x}_${patch.y}`;
                const quality = qualityMap[key];
                const highlighted = quality && quality.highlighted_cell ? quality.highlighted_cell : null;
                return {
                    ...patch,
                    index: idx,
                    verified: undefined, // undefined = unlabeled, true = Yes, false = No
                    image_url: quality && quality.image_url ? quality.image_url : null,
                    cells_detected: quality ? quality.cells_detected : 0,
                    highlighted_cell: highlighted,
                    is_background: quality ? !!quality.is_background : false,
                    quality_info: quality || null
                };
            });
            console.log('Initialized patches data:', window.allPatchesData.length);
            
            // Use precomputed quality checks (fastest)
            if (qualityChecks.length > 0) {
                console.log(`Using precomputed quality checks: ${qualityChecks.length} entries`);
                const infoEl = document.getElementById('candidatePoolInfo');
                const validcount = window.allPatchesData.filter(p => !p.is_background).length;
                const backgroundcount = window.allPatchesData.length - validcount;
                if (infoEl) {
                    infoEl.innerHTML = `Candidate Pool (0 / ${validcount} patches verified) <span style="color: #2ecc71; font-size: 12px;">${backgroundcount} background patches filtered (precomputed)</span>`;
                }
                rendercurrentPage();
                updateAccuracyPanel();
                return;
            }
            
            // If backend already filtered(has tissue_mask),use directly
            // If not,actively load patches to filter background
            if (data.filtered_by_tissue_mask) {
                console.log('Backend already filtered patches using tissue_mask');
                // Backend already filtered,render directly
                const infoEl = document.getElementById('candidatePoolInfo');
                if (infoEl) {
                    infoEl.innerHTML = `Candidate Pool (0 / ${data.total_patches} patches verified) <span style="color: #2ecc71; font-size: 12px;">Background filtered by tissue mask</span>`;
                }
                rendercurrentPage();
                updateAccuracyPanel();
            } else {
                console.log('No tissue_mask, pre-loading ALL patches to filter background...');
                console.log(`   This may take a while for ${window.allPatchesData.length} patches...`);
                
                // Show loading prompt
                const infoEl = document.getElementById('candidatePoolInfo');
                if (infoEl) {
                    infoEl.innerHTML = `Candidate Pool <span style="color: #f39c12;">Loading patches to filter background...</span>`;
                }
                
                // Asynchronously load all patches(batch processing,avoid blocking)
                const batchSize = 10;
                let processed = 0;
                
                for (let i = 0; i < window.allPatchesData.length; i += batchSize) {
                    const batch = [];
                    for (let j = i; j < Math.min(i + batchSize, window.allPatchesData.length); j++) {
                        batch.push(loadPatchImage(j).catch(err => {
                            window.allPatchesData[j].is_background = true;
                        }));
                    }
                    
                    await Promise.all(batch);
                    processed += batch.length;
                    
                    // Update progress and display in real-time
                    const validcount = window.allPatchesData.slice(0, processed).filter(p => !p.is_background).length;
                    if (infoEl) {
                        infoEl.innerHTML = `Candidate Pool <span style="color: #f39c12;">Processing ${processed}/${window.allPatchesData.length} (${validcount} with cells)</span>`;
                    }
                    
                    // Re-render after each batch
                    if (processed % (batchSize * 3) === 0) {
                        rendercurrentPage();
                    }
                }
                
                // Final statistics
                const validPatches = window.allPatchesData.filter(p => !p.is_background);
                const backgroundcount = window.allPatchesData.length - validPatches.length;
                console.log(`Filtering complete: ${validPatches.length} patches with cells, ${backgroundcount} background filtered`);
                
                if (infoEl) {
                    infoEl.innerHTML = `Candidate Pool (0 / ${validPatches.length} patches verified) <span style="color: #2ecc71; font-size: 12px;">${backgroundcount} background patches filtered</span>`;
                }
                
                rendercurrentPage();
                updateAccuracyPanel();
            }
        } catch (e) {
            console.error("Error loading patches:", e);
            const container = document.getElementById('patchesContainer');
            if (container) {
                container.innerHTML = `<div style="color: #ff6b6b; text-align: center; padding: 20px;">Error loading patches: ${e.message}<br>Please check the browser console for details.</div>`;
            }
        }
    };
    
    // Render current page patches
    function rendercurrentPage() {
        const container = document.getElementById('patchesContainer');
        if (!container) return;
        
        // Filter out background patches(without cells)
        const validPatches = window.allPatchesData.filter(p => !p.is_background);
        
        const startIdx = (window.currentPage - 1) * window.patchesPerPage;
        const endIdx = Math.min(startIdx + window.patchesPerPage, validPatches.length);
        const currentPagePatches = validPatches.slice(startIdx, endIdx);
        
        // Update Candidate Pool information,Show filtered count
        const infoEl = document.getElementById('candidatePoolInfo');
        if (infoEl) {
            const verifiedcount = validPatches.filter(p => p.verified !== undefined).length;
            const totalPatches = window.allPatchesData.length;
            const backgroundcount = totalPatches - validPatches.length;
            const filterInfo = backgroundcount > 0 
                ? ` <span style="color: #2ecc71; font-size: 12px;">${backgroundcount} background patches filtered</span>` 
                : '';
            infoEl.innerHTML = `Candidate Pool (${verifiedcount} / ${validPatches.length} patches verified)${filterInfo}`;
        }
        
        // update pagination information
        const totalPages = Math.ceil(validPatches.length / window.patchesPerPage);
        const currentPageEl = document.getElementById('currentPage');
        const totalPagesEl = document.getElementById('totalPages');
        const prevBtn = document.getElementById('prevPageBtn');
        const nextBtn = document.getElementById('nextPageBtn');
        
        if (currentPageEl) currentPageEl.textContent = window.currentPage;
        if (totalPagesEl) totalPagesEl.textContent = totalPages;
        
        // update button status and style
        if (prevBtn) {
            const isDisabled = window.currentPage <= 1;
            prevBtn.disabled = isDisabled;
            prevBtn.style.opacity = isDisabled ? '0.3' : '1';
            prevBtn.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
        }
        if (nextBtn) {
            const isDisabled = window.currentPage >= totalPages;
            nextBtn.disabled = isDisabled;
            nextBtn.style.opacity = isDisabled ? '0.3' : '1';
            nextBtn.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
        }
        
        // Render patches (Only render valid patches)
        let html = '';
        currentPagePatches.forEach((patch, localIdx) => {
            // Use original index(Find from allPatchesData)
            const globalIdx = window.allPatchesData.indexOf(patch);
            const patchId = `patch-${globalIdx}`;
            const verifiedClass = patch.verified === true ? 'patch-verified' : (patch.verified === false ? 'patch-rejected' : '');
            const isSelected = globalIdx === window.currentPatchIndex ? 'patch-selected' : '';
            const cellInfo = patch.highlighted_cell || {};
            
            const imageUrl = patch.image_url 
                ? `http://127.0.0.1:8000${patch.image_url}`
                : 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMWExZDI5Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtc2l6ZT0iMTgiIGZpbGw9IiM4ODg4ODgiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5Mb2FkaW5nLi4uPC90ZXh0Pjwvc3ZnPg==';
            
            html += `
                <div class="patch-item ${verifiedClass} ${isSelected}" id="${patchId}" 
                     onclick="selectPatch(${globalIdx})"
                     data-patch-index="${globalIdx}">
                    <img src="${imageUrl}" alt="Patch ${globalIdx + 1}" 
                         class="patch-image-clickable"
                         data-patch-index="${globalIdx}"
                         style="cursor: pointer; pointer-events: auto; width: 100%; height: 100%; object-fit: cover; z-index: 10; position: relative;"
                         onerror="this.parentElement.innerHTML='<div style=\\'padding:10px; color:#ff6b6b\\'>Image load error</div>'">
                    <div class="patch-info">
                        <div style="font-size: 11px; margin-bottom: 5px; font-weight: 500;">Patch ${globalIdx + 1}</div>
                        <div style="font-size: 10px; color: #888;">(${patch.x}, ${patch.y})</div>
                        ${cellInfo.cell_id ? `
                            <div style="font-size: 10px; color: #a0a0a0; margin-top: 3px;">
                                <strong>Cell ID:</strong> ${cellInfo.cell_id}
                            </div>
                            <div style="font-size: 10px; color: #a0a0a0;">
                                <strong>Pos:</strong> (${cellInfo.position[0]}, ${cellInfo.position[1]})
                            </div>
                        ` : ''}
                    </div>
                    <div class="patch-actions">
                        <button class="patch-btn patch-btn-yes" onclick="verifyPatch(${globalIdx}, true, event)" ${patch.verified !== undefined ? 'disabled' : ''}>
                            Yes
                        </button>
                        <button class="patch-btn patch-btn-no" onclick="verifyPatch(${globalIdx}, false, event)" ${patch.verified !== undefined ? 'disabled' : ''}>
                            No
                        </button>
                    </div>
                </div>
            `;
        });
        container.innerHTML = html;
        
        // Bind image click events (use event delegation, more reliable)
        setTimeout(() => {
            container.querySelectorAll('.patch-image-clickable').forEach(img => {
                const patchIndex = parseInt(img.getAttribute('data-patch-index'));
                img.addEventListener('click', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    console.log('Image clicked via event listener, patch index:', patchIndex);
                    if (window.handlePatchImageClick) {
                        window.handlePatchImageClick(e, patchIndex);
                    } else {
                        console.error('handlePatchImageClick function not found');
                        // Directly call showImageModal as fallback
                        const patch = window.allPatchesData && window.allPatchesData[patchIndex];
                        if (patch) {
                            if (!patch.image_url) {
                                loadPatchImage(patchIndex).then(() => {
                                    const updatedPatch = window.allPatchesData[patchIndex];
                                    // Check whether is background
                                    if (updatedPatch && updatedPatch.is_background) {
                                        console.log('Patch is background, filtering out');
                                        rendercurrentPage();
                                        return;
                                    }
                                    if (updatedPatch && updatedPatch.image_url) {
                                        const imageUrl = updatedPatch.image_url.startsWith('http') 
                                            ? updatedPatch.image_url 
                                            : `http://127.0.0.1:8000${updatedPatch.image_url}`;
                                        if (window.showImageModal) {
                                            window.showImageModal(imageUrl, updatedPatch.cells_detected || 0, updatedPatch.x, updatedPatch.y);
                                        }
                                    }
                                }).catch(() => {
                                    // Silently handle background patch
                                    patch.is_background = true;
                                    rendercurrentPage();
                                });
                            } else {
                                const imageUrl = patch.image_url.startsWith('http') 
                                    ? patch.image_url 
                                    : `http://127.0.0.1:8000${patch.image_url}`;
                                if (window.showImageModal) {
                                    window.showImageModal(imageUrl, patch.cells_detected || 0, patch.x, patch.y, patchIndex);
                                }
                            }
                        }
                    }
                }, true); // Use capture phase to ensure priority handling
            });
        }, 50);
        
        // Lazy load images (if not loaded yet)
        currentPagePatches.forEach((patch) => {
            // Use real index of patch in allPatchesData
            const globalIdx = window.allPatchesData.indexOf(patch);
            if (globalIdx !== -1 && !patch.image_url && !patch.is_background) {
                loadPatchImage(globalIdx);
            }
        });
    }
    
    // Handle patch image click events (global function, ensure it can be called)
    window.handlePatchImageClick = function(event, patchIndex) {
        console.log('handlePatchImageClick called:', patchIndex);
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        
        const patch = window.allPatchesData && window.allPatchesData[patchIndex];
        if (!patch) {
            console.error('Patch not found:', patchIndex, 'Total patches:', window.allPatchesData?.length);
            alert('Patch not found. Please refresh the page.');
            return;
        }
        
        console.log('Patch data:', patch);
        
        // If image not loaded yet, load it first
        if (!patch.image_url) {
            console.log('Loading patch image first...', patch.x, patch.y);
            loadPatchImage(patchIndex).then(() => {
                console.log('Patch image loaded, checking if background...');
                // Call again after loading completes
                setTimeout(() => {
                    const updatedPatch = window.allPatchesData[patchIndex];
                    
                    // Check whether is background region
                    if (updatedPatch && updatedPatch.is_background) {
                        console.log('Patch is background, will be filtered out');
                        // Do not show alert, silently handle,Re-render page(patch will be automatically filtered)
                        rendercurrentPage();
                        return;
                    }
                    
                    if (updatedPatch && updatedPatch.image_url) {
                        const imageUrl = updatedPatch.image_url.startsWith('http') 
                            ? updatedPatch.image_url 
                            : `http://127.0.0.1:8000${updatedPatch.image_url}`;
                        showImageModal(imageUrl, updatedPatch.cells_detected || 0, updatedPatch.x, updatedPatch.y);
                    }
                }, 100);
            }).catch(err => {
                console.error('failed to load patch image:', err);
                // Do not show alert,Silently mark as background
                patch.is_background = true;
                rendercurrentPage();
            });
            return;
        }
        
        const imageUrl = patch.image_url.startsWith('http') 
            ? patch.image_url 
            : `http://127.0.0.1:8000${patch.image_url}`;
        
        console.log('Opening modal with URL:', imageUrl);
        if (window.showImageModal) {
            window.showImageModal(imageUrl, patch.cells_detected || 0, patch.x, patch.y, patchIndex);
        } else {
            console.error('showImageModal function not found');
        }
    };
    
    // Load single patch image
    async function loadPatchImage(index) {
        if (index < 0 || index >= window.allPatchesData.length) {
            return Promise.reject('Invalid patch index');
        }
        
        // Check whether job is loaded
        if (!currentJobId) {
            return Promise.reject('No job loaded');
        }
        
        const patch = window.allPatchesData[index];
        if (patch.image_url) {
            return Promise.resolve(); // Already loaded
        }
        
        try {
            // Pass job_id parameter
            const response = await fetch(`http://127.0.0.1:8000/debug/verify-patch?job_id=${currentJobId}&x=${patch.x}&y=${patch.y}&return_json=true`);
            if (!response.ok) throw new Error(`Server error: ${response.status}`);
            
            const data = await response.json();
            patch.image_url = data.image_url;
            patch.cells_detected = data.cells_detected || 0;
            patch.all_detected = data.all_detected || data.cells_detected || 0;
            patch.displayed = data.displayed || data.cells_detected || 0;
            patch.highlighted_cell = data.highlighted_cell;
            patch.filtered = data.filtered || {};
            
            // Check whether is background region(no cells)
            if (patch.cells_detected === 0) {
                patch.is_background = true;
                console.log(`Patch ${index} marked as background (no cells detected)`);
            } else {
                patch.is_background = false;
                // console.log('Patch loaded:', patch);
            }
            
            // Re-render current page
            rendercurrentPage();
            return Promise.resolve();
        } catch (e) {
            console.error(`Error loading patch ${index}:`, e);
            // Mark as background(load failed usually means filtered)
            patch.is_background = true;
            return Promise.reject(e);
        }
    }
    
    // Select patch (for keyboard navigation)
    function selectPatch(index) {
        window.currentPatchIndex = index;
        rendercurrentPage();
    }
    
    // Verify patch (global function)
    window.verifyPatch = function(index, isCorrect, event) {
        if (event) event.stopPropagation();
        if (index < 0 || index >= window.allPatchesData.length) {
            console.error('Invalid patch index:', index);
            return;
        }
        
        window.allPatchesData[index].verified = isCorrect;
        rendercurrentPage();
        updateAccuracyPanel();
        
        // update Candidate Pool information
        const infoEl = document.getElementById('candidatePoolInfo');
        if (infoEl) {
            const verifiedcount = window.allPatchesData.filter(p => p.verified !== undefined).length;
            infoEl.textContent = `Candidate Pool (${verifiedcount} / ${window.allPatchesData.length} patches verified)`;
        }
        
        // Automatically move to next unlabeled patch
        const nextUnverified = window.allPatchesData.findIndex((p, idx) => idx > index && p.verified === undefined);
        if (nextUnverified !== -1) {
            // If next unlabeled patch is on current page, select directly; otherwise change page
            const nextPage = Math.ceil((nextUnverified + 1) / window.patchesPerPage);
            if (nextPage === window.currentPage) {
                window.currentPatchIndex = nextUnverified;
                rendercurrentPage();
            } else {
                window.currentPage = nextPage;
                window.currentPatchIndex = nextUnverified;
                rendercurrentPage();
            }
        }
    };
    
    // Change page
    function previousPage() {
        if (window.currentPage > 1) {
            window.currentPage--;
            window.currentPatchIndex = (window.currentPage - 1) * window.patchesPerPage;
            rendercurrentPage();
        }
    }
    
    function nextPage() {
        const totalPages = Math.ceil(window.allPatchesData.length / window.patchesPerPage);
        if (window.currentPage < totalPages) {
            window.currentPage++;
            window.currentPatchIndex = (window.currentPage - 1) * window.patchesPerPage;
            rendercurrentPage();
        }
    }
    
    // update accuracy panel
    function updateAccuracyPanel() {
        const panel = document.getElementById('accuracyPanel');
        const content = document.getElementById('accuracyContent');
        if (!panel || !content) return;
        
        const verifiedPatches = window.allPatchesData.filter(p => p.verified !== undefined);
        if (verifiedPatches.length === 0) {
            panel.style.display = 'none';
            return;
        }
        
        panel.style.display = 'block';
        const correctcount = verifiedPatches.filter(p => p.verified === true).length;
        const incorrectcount = verifiedPatches.filter(p => p.verified === false).length;
        const accuracy = (correctcount / verifiedPatches.length * 100).toFixed(1);
        
        content.innerHTML = `
            <!-- Color legend -->
            <div style="background: #1a1d29; border: 1px solid #2f3342; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <div style="color: #e0e0e0; font-size: 13px; font-weight: bold; margin-bottom: 10px;">Color Legend:</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; font-size: 12px; color: #a0a0a0;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; border: 2px solid #ffd700; border-radius: 2px; background: rgba(255, 215, 0, 0.1);"></div>
                        <span><span style="color: #ffd700;">Yellow outline</span> + <span style="color: #2ecc71;">green center</span>: Displayed (passed all filters)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; border: 2px solid #e74c3c; border-radius: 2px;"></div>
                        <span><span style="color: #e74c3c;">Red outline</span>: Edge Filtered (removed to avoid duplicates)</span>
                    </div>
                </div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span style="color: #a0a0a0;">Accuracy:</span>
                    <span style="color: #2ecc71; font-size: 18px; font-weight: bold;">${accuracy}%</span>
                </div>
                <div style="background: #0f111a; height: 20px; border-radius: 10px; overflow: hidden; margin-bottom: 10px;">
                    <div style="background: linear-gradient(90deg, #2ecc71 0%, #27ae60 100%); height: 100%; width: ${accuracy}%; transition: width 0.3s;"></div>
                </div>
                <div style="display: flex; gap: 20px; font-size: 12px; color: #888;">
                    <div>Correct: <span style="color: #2ecc71;">${correctcount}</span></div>
                    <div>Incorrect: <span style="color: #e74c3c;">${incorrectcount}</span></div>
                    <div>Total: <span style="color: #5c7cfa;">${verifiedPatches.length}</span></div>
                </div>
            </div>
        `;
    }
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // If modal is open, handle modal shortcuts
        const modal = document.getElementById('imageModal');
        if (modal && modal.classList.contains('active')) {
            // Left/right arrow keys to switch patches
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                navigatePatch(-1);
                return;
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                navigatePatch(1);
                return;
            }
            // ESC key to close modal
            if (e.key === 'Escape') {
                e.preventDefault();
                closeImageModal();
                return;
            }
        }
        
        // Only respond when patches sidebar is open
        const sidebar = document.getElementById('sidebar');
        if (!sidebar || !sidebar.classList.contains('active') || sidebar.dataset.mode !== 'patches') {
            return;
        }
        
        // Y key = Yes
        if (e.key === 'y' || e.key === 'Y') {
            e.preventDefault();
            const currentPatch = window.allPatchesData[window.currentPatchIndex];
            if (currentPatch && currentPatch.verified === undefined) {
                verifyPatch(window.currentPatchIndex, true);
            }
        }
        
        // N key = No
        if (e.key === 'n' || e.key === 'N') {
            e.preventDefault();
            const currentPatch = window.allPatchesData[window.currentPatchIndex];
            if (currentPatch && currentPatch.verified === undefined) {
                verifyPatch(window.currentPatchIndex, false);
            }
        }
        
        // Arrow key navigation
        if (e.key === 'ArrowLeft' && window.currentPatchIndex > 0) {
            e.preventDefault();
            window.currentPatchIndex--;
            const newPage = Math.ceil((window.currentPatchIndex + 1) / window.patchesPerPage);
            if (newPage !== window.currentPage) {
                window.currentPage = newPage;
            }
            rendercurrentPage();
        }
        
        if (e.key === 'ArrowRight' && window.currentPatchIndex < window.allPatchesData.length - 1) {
            e.preventDefault();
            window.currentPatchIndex++;
            const newPage = Math.ceil((window.currentPatchIndex + 1) / window.patchesPerPage);
            if (newPage !== window.currentPage) {
                window.currentPage = newPage;
            }
            rendercurrentPage();
        }
    });
    
    // Store currently open patch information
    window.currentModalPatch = null;
    
    // Global function, ensure it can be called
    window.showImageModal = function(imageUrl, cells, x, y, patchIndex = null) {
        console.log('showImageModal called:', imageUrl, cells, x, y, patchIndex);
        const modal = document.getElementById('imageModal');
        const img = document.getElementById('modalImage');
        if (!modal) {
            console.error('Modal element not found');
            alert('Modal element not found. Please check the page structure.');
            return;
        }
        if (!img) {
            console.error('Modal image element not found');
            alert('Modal image element not found. Please check the page structure.');
            return;
        }
        
        // Save current patch index and information
        if (patchIndex !== null && window.allPatchesData) {
            window.currentModalPatchIndex = patchIndex;
            window.currentModalPatch = window.allPatchesData[patchIndex];
            console.log('current patch data:', window.currentModalPatch);
        } else if (window.allPatchesData) {
            // If patchIndex not provided, try to find by coordinates
            const foundIndex = window.allPatchesData.findIndex(p => p.x === x && p.y === y);
            if (foundIndex !== -1) {
                window.currentModalPatchIndex = foundIndex;
                window.currentModalPatch = window.allPatchesData[foundIndex];
                console.log('Found patch by coordinates:', window.currentModalPatch);
            } else {
                window.currentModalPatchIndex = null;
                window.currentModalPatch = null;
            }
        } else {
            window.currentModalPatchIndex = null;
            window.currentModalPatch = null;
        }
        
        // update navigation button status
        updateModalNavButtons();
        
        // Ensure using full URL
        let fullUrl = imageUrl;
        if (!imageUrl.startsWith('http') && !imageUrl.startsWith('data:')) {
            fullUrl = `http://127.0.0.1:8000${imageUrl}`;
        }
        
        console.log('Setting image src to:', fullUrl);
        img.src = fullUrl;
        img.alt = `Patch at (${x}, ${y}) - ${cells} cells`;
        
        // update info panel
        const patchCoordsEl = document.getElementById('modalPatchCoords');
        const cellscountEl = document.getElementById('modalCellscount');
        const cellIdEl = document.getElementById('modalCellId');
        const positionEl = document.getElementById('modalPosition');
        const correctBtn = document.getElementById('modalCorrectBtn');
        const incorrectBtn = document.getElementById('modalIncorrectBtn');
        
        console.log('Updating info panel elements...');
        console.log('current patch data:', window.currentModalPatch);
        
        // update Patch coordinates
        if (patchCoordsEl) {
            patchCoordsEl.textContent = `(${x}, ${y})`;
            console.log('updated Patch coords to:', `(${x}, ${y})`);
        } else {
            console.error('modalPatchCoords element not found');
        }
        
        // update Segmentation count (display all detected segmentations)
        if (cellscountEl) {
            // Prefer information from patch data
            let cellsDisplay = cells || 0;
            if (window.currentModalPatch) {
                // If all_detected exists, display all detected
                if (window.currentModalPatch.all_detected !== undefined) {
                    cellsDisplay = window.currentModalPatch.all_detected;
                } else if (window.currentModalPatch.cells_detected !== undefined) {
                    cellsDisplay = window.currentModalPatch.cells_detected;
                }
            }
            cellscountEl.textContent = cellsDisplay;
            console.log('updated Segmentation count to:', cellsDisplay);
        } else {
            console.error('modalCellscount element not found');
        }
        
        // update Cell ID (highlighted cell ID)
        if (cellIdEl) {
            if (window.currentModalPatch && window.currentModalPatch.highlighted_cell && window.currentModalPatch.highlighted_cell.cell_id !== undefined) {
                const cellId = window.currentModalPatch.highlighted_cell.cell_id;
                cellIdEl.textContent = `#${cellId}`;
                console.log('updated Cell ID to:', `#${cellId}`);
            } else {
                cellIdEl.textContent = 'N/A';
                console.log('No highlighted cell, Cell ID set to N/A');
            }
        } else {
            console.error('modalCellId element not found');
        }
        
        // update Position (highlighted cell global coordinates)
        if (positionEl) {
            if (window.currentModalPatch && window.currentModalPatch.highlighted_cell && window.currentModalPatch.highlighted_cell.position) {
                const pos = window.currentModalPatch.highlighted_cell.position;
                positionEl.textContent = `(${pos[0]}, ${pos[1]})`;
                console.log('updated Position to:', `(${pos[0]}, ${pos[1]})`);
            } else {
                positionEl.textContent = 'N/A';
                console.log('No highlighted cell, Position set to N/A');
            }
        } else {
            console.error('modalPosition element not found');
        }
        
        // update detailed segmentation information
        const detailsPanel = document.getElementById('modalSegmentationDetails');
        const allDetectedEl = document.getElementById('modalAllDetected');
        const displayedEl = document.getElementById('modalDisplayed');
        const filteredEl = document.getElementById('modalFiltered');
        
        if (window.currentModalPatch && (window.currentModalPatch.all_detected !== undefined || window.currentModalPatch.filtered)) {
            if (detailsPanel) detailsPanel.style.display = 'block';
            
            if (allDetectedEl && window.currentModalPatch.all_detected !== undefined) {
                allDetectedEl.textContent = window.currentModalPatch.all_detected;
            }
            
            if (displayedEl && window.currentModalPatch.displayed !== undefined) {
                displayedEl.textContent = window.currentModalPatch.displayed;
            }
            
            if (filteredEl && window.currentModalPatch.filtered) {
                const filtered = window.currentModalPatch.filtered;
                const totalFiltered = (filtered.by_area || 0) + (filtered.by_edge || 0) + (filtered.by_shape || 0);
                filteredEl.textContent = `${totalFiltered} (area: ${filtered.by_area || 0}, edge: ${filtered.by_edge || 0}, shape: ${filtered.by_shape || 0})`;
            }
        } else {
            if (detailsPanel) detailsPanel.style.display = 'none';
        }
        
        // update button status
        if (window.currentModalPatch) {
            const isVerified = window.currentModalPatch.verified !== undefined;
            if (correctBtn) {
                correctBtn.disabled = isVerified;
                correctBtn.style.opacity = isVerified ? '0.5' : '1';
            }
            if (incorrectBtn) {
                incorrectBtn.disabled = isVerified;
                incorrectBtn.style.opacity = isVerified ? '0.5' : '1';
            }
        }
        
        // update navigation button status
        updateModalNavButtons();
        
        // Show modal
        modal.classList.add('active');
        console.log('Modal should be visible now. Modal classList:', modal.classList.toString());
        
        // Prevent event bubbling to avoid closing modal when clicking image
        img.onclick = (e) => {
            if (e) {
                e.stopPropagation();
            }
        };
        
        // Add error handling
        img.onerror = function() {
            console.error('failed to load image:', fullUrl);
            alert('failed to load image: ' + fullUrl);
        };
        
        // Add load success handling
        img.onload = function() {
            console.log('Image loaded successfully:', fullUrl);
        };
    };
    
    // Mark patch as correct
    function markPatchCorrect() {
        if (!window.currentModalPatch) {
            console.error('No patch selected');
            return;
        }
        
        const patchIndex = window.currentModalPatch.index;
        if (patchIndex !== undefined && window.verifyPatch) {
            window.verifyPatch(patchIndex, true);
            closeImageModal();
        } else {
            console.error('Cannot mark patch as correct: patch index not found');
        }
    }
    
    // Mark patch as incorrect
    function markPatchIncorrect() {
        if (!window.currentModalPatch) {
            console.error('No patch selected');
            return;
        }
        
        const patchIndex = window.currentModalPatch.index;
        if (patchIndex !== undefined && window.verifyPatch) {
            window.verifyPatch(patchIndex, false);
            closeImageModal();
        } else {
            console.error('Cannot mark patch as incorrect: patch index not found');
        }
    }
    
    // Ensure function is global
    window.markPatchCorrect = markPatchCorrect;
    window.markPatchIncorrect = markPatchIncorrect;
    
    function closeImageModal() {
        const modal = document.getElementById('imageModal');
        modal.classList.remove('active');
    }
    
    // update modal navigation button status
    function updateModalNavButtons() {
        const prevBtn = document.getElementById('modalPrevBtn');
        const nextBtn = document.getElementById('modalNextBtn');
        
        if (!prevBtn || !nextBtn || !window.allPatchesData) {
            if (prevBtn) prevBtn.style.display = 'none';
            if (nextBtn) nextBtn.style.display = 'none';
            return;
        }
        
        const currentIndex = window.currentModalPatchIndex;
        const totalPatches = window.allPatchesData.length;
        
        if (currentIndex === null || currentIndex === undefined) {
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
            return;
        }
        
        // Show buttons
        prevBtn.style.display = 'flex';
        nextBtn.style.display = 'flex';
        
        // update button status
        prevBtn.disabled = currentIndex <= 0;
        nextBtn.disabled = currentIndex >= totalPatches - 1;
    }
    
    // Navigate to previous/next patch
    function navigatePatch(direction) {
        if (!window.allPatchesData || window.currentModalPatchIndex === null || window.currentModalPatchIndex === undefined) {
            return;
        }
        
        // Use validPatches(filter out background)for navigation
        const validPatches = window.allPatchesData.filter(p => !p.is_background);
        const currentValidIndex = validPatches.findIndex(p => window.allPatchesData.indexOf(p) === window.currentModalPatchIndex);
        
        if (currentValidIndex === -1) {
            console.error('current patch not in valid patches list');
            return;
        }
        
        const newValidIndex = currentValidIndex + direction;
        
        if (newValidIndex < 0 || newValidIndex >= validPatches.length) {
            return;
        }
        
        const patch = validPatches[newValidIndex];
        const newIndex = window.allPatchesData.indexOf(patch);
        
        if (!patch) {
            return;
        }
        
        // Load patch image
        if (!patch.image_url) {
            loadPatchImage(newIndex).then(() => {
                const updatedPatch = window.allPatchesData[newIndex];
                // Check again whether is background(just in case)
                if (updatedPatch && updatedPatch.is_background) {
                    console.log('Patch became background after loading, skipping');
                    // Continue navigation to next
                    navigatePatch(direction);
                    return;
                }
                if (updatedPatch && updatedPatch.image_url) {
                    const imageUrl = updatedPatch.image_url.startsWith('http') 
                        ? updatedPatch.image_url 
                        : `http://127.0.0.1:8000${updatedPatch.image_url}`;
                    window.showImageModal(imageUrl, updatedPatch.cells_detected || 0, updatedPatch.x, updatedPatch.y, newIndex);
                }
            }).catch(err => {
                console.error('failed to load patch image:', err);
                // Mark as background,Continue navigation
                patch.is_background = true;
                navigatePatch(direction);
            });
        } else {
            const imageUrl = patch.image_url.startsWith('http') 
                ? patch.image_url 
                : `http://127.0.0.1:8000${patch.image_url}`;
            window.showImageModal(imageUrl, patch.cells_detected || 0, patch.x, patch.y, newIndex);
        }
    }
    
    // Select patch and show verification panel
    function selectPatch(index) {
        if (!window.patchesData || index < 0 || index >= window.patchesData.length) return;
        
        window.currentPatchIndex = index;
        
        // update selected status
        document.querySelectorAll('.patch-item').forEach((item, idx) => {
            if (idx === index) {
                item.classList.add('patch-selected');
            } else {
                item.classList.remove('patch-selected');
            }
        });
        
        // Show verification panel
        showVerificationPanel(index);
        
        // Highlight patch position in main view (optional)
        highlightPatchInMainView(window.patchesData[index]);
    }
    
    // Show verification panel
    function showVerificationPanel(index) {
        const patch = window.patchesData[index];
        const panel = document.getElementById('verificationPanel');
        const content = document.getElementById('verificationContent');
        
        if (!panel || !content || !patch) return;
        
        panel.style.display = 'block';
        
        const imageUrl = `http://127.0.0.1:8000${patch.overlay_url}`;
        const quality = patch.segmentation_quality || {};
        const sizeInfo = patch.patch_size_info || {};
        const highlightedCell = patch.highlighted_cell || {};
        
        // Calculate quality score color
        const qualityScore = quality.score || 0;
        let qualityColor = '#4caf50'; // Green
        if (qualityScore < 0.5) qualityColor = '#f44336'; // Red
        else if (qualityScore < 0.7) qualityColor = '#ff9800'; // Orange
        
        // Patch size status
        let sizeStatusText = 'Normal';
        let sizeStatusColor = '#4caf50';
        if (sizeInfo.status === 'too_large') {
            sizeStatusText = 'Too Large';
            sizeStatusColor = '#f44336';
        } else if (sizeInfo.status === 'too_small') {
            sizeStatusText = 'Too Small';
            sizeStatusColor = '#ff9800';
        }
        
        content.innerHTML = `
            <div style="margin-bottom: 15px;">
                <h3 style="margin: 0 0 10px 0; color: #e0e0e0; font-size: 16px;">Patch ${index + 1} Verification</h3>
                <img src="${imageUrl}" alt="Patch ${index + 1}" 
                     style="width: 100%; border-radius: 6px; margin-bottom: 15px; border: 2px solid #2f3342;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="color: #a0a0a0; font-size: 13px;">Segmentation Quality:</span>
                    <span style="color: ${qualityColor}; font-weight: 600; font-size: 14px;">
                        ${(qualityScore * 100).toFixed(1)}%
                    </span>
                </div>
                <div style="background: #0f111a; height: 6px; border-radius: 3px; overflow: hidden;">
                    <div style="background: ${qualityColor}; height: 100%; width: ${qualityScore * 100}%; transition: width 0.3s;"></div>
                </div>
                <div style="margin-top: 8px; font-size: 11px; color: #888;">
                    Circularity: ${((quality.circularity || 0) * 100).toFixed(1)}% | 
                    Area: ${Math.round(quality.area || 0)} px¬≤
                </div>
            </div>
            
            <div style="margin-bottom: 15px; padding: 12px; background: #0f111a; border-radius: 6px; border: 1px solid #2f3342;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="color: #a0a0a0; font-size: 13px;">Patch Size:</span>
                    <span style="color: ${sizeStatusColor}; font-weight: 600; font-size: 13px;">${sizeStatusText}</span>
                </div>
                <div style="font-size: 11px; color: #888; line-height: 1.6;">
                    BBox: ${sizeInfo.bbox_width || 'N/A'} √ó ${sizeInfo.bbox_height || 'N/A'} px<br>
                    Ratio: ${((sizeInfo.ratio || 0) * 100).toFixed(2)}% of patch
                </div>
            </div>
            
            ${highlightedCell.label_id ? `
            <div style="margin-bottom: 15px; padding: 12px; background: #0f111a; border-radius: 6px; border: 1px solid #2f3342;">
                <div style="color: #a0a0a0; font-size: 13px; margin-bottom: 5px;">Highlighted Cell:</div>
                <div style="font-size: 12px; color: #e0e0e0;">
                    Cell ID: ${highlightedCell.label_id}<br>
                    Position: (${highlightedCell.global_centroid?.[0] || 'N/A'}, ${highlightedCell.global_centroid?.[1] || 'N/A'})
                </div>
            </div>
            ` : ''}
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="patch-btn patch-btn-yes" 
                        onclick="verifyPatch(${index}, true)"
                        style="flex: 1; padding: 12px; font-size: 14px;">
                    Correct
                </button>
                <button class="patch-btn patch-btn-no" 
                        onclick="verifyPatch(${index}, false)"
                        style="flex: 1; padding: 12px; font-size: 14px;">
                    Incorrect
                </button>
            </div>
        `;
    }
    
    // Highlight patch position in main view
    function highlightPatchInMainView(patch) {
        if (!patch || !patch.patch_coords || !viewer) return;
        
        const coords = patch.patch_coords;
        const x = coords.x;
        const y = coords.y;
        const size = coords.tile_size;
        
        // Calculate patch position in image (need to scale based on image dimensions)
        // Simplified here, should actually calculate based on OpenSeadragon coordinate system
        console.log(`Highlighting patch at (${x}, ${y}) with size ${size}`);
        
        // Can add a rectangular overlay to highlight patch area
        // Record here for now, can implement later
    }
    
    // Verify patch segmentation quality
    function verifyPatch(index, isCorrect) {
        if (!window.patchesData || index < 0 || index >= window.patchesData.length) return;
        
        const patch = window.patchesData[index];
        const patchId = `patch-${index}`;
        const patchElement = document.getElementById(patchId);
        
        if (patchElement) {
            // update style
            if (isCorrect) {
                patchElement.classList.add('patch-verified');
                patchElement.classList.remove('patch-rejected');
                console.log(`Patch ${index + 1} verified as CORRECT`, patch);
            } else {
                patchElement.classList.add('patch-rejected');
                patchElement.classList.remove('patch-verified');
                console.log(`Patch ${index + 1} marked as INCORRECT`, patch);
            }
        }
        
        // Disable verification button
        const buttons = document.querySelectorAll('#verificationContent .patch-btn');
        buttons.forEach(btn => btn.disabled = true);
        
        // Can add follow-up logic here, such as:
        // - Send verification results to backend
        // - Record verification statistics
        // - Automatically switch to next patch
    }
    
    // Test server connection
    async function testConnection() {
        updateStatus("Testing connection...");
        try {
            const response = await fetch('http://127.0.0.1:8000/debug/jobs');
            if (response.ok) {
                const jobs = await response.json();
                updateStatus(`Server connected. Found ${jobs.length} jobs.`);
                
                // Filter completed jobs
                const succeededJobs = jobs.filter(j => j.status === "SUCCEEDED");
                const otherJobs = jobs.filter(j => j.status !== "SUCCEEDED");
                
                let message = `Server is running!\n\nFound ${jobs.length} jobs in database.\n\n`;
                
                if (succeededJobs.length > 0) {
                    message += `Ready to view (${succeededJobs.length}):\n`;
                    succeededJobs.slice(0, 5).forEach(j => {
                        message += `  ‚Ä¢ ${j.id}\n    Name: ${j.name || 'N/A'}\n`;
                    });
                    if (succeededJobs.length > 5) {
                        message += `  ... and ${succeededJobs.length - 5} more\n`;
                    }
                }
                
                if (otherJobs.length > 0) {
                    message += `\nOther status (${otherJobs.length}):\n`;
                    const statuscounts = {};
                    otherJobs.forEach(j => {
                        statuscounts[j.status] = (statuscounts[j.status] || 0) + 1;
                    });
                    Object.entries(statuscounts).forEach(([status, count]) => {
                        message += `  ‚Ä¢ ${status}: ${count}\n`;
                    });
                }
                
                if (succeededJobs.length === 0) {
                    message += `\nNo completed jobs found. Please submit a new workflow and wait for it to complete.`;
                }
                
                alert(message);
                console.log("All jobs:", jobs.map(j => ({ 
                    id: j.id, 
                    name: j.name, 
                    status: j.status,
                    job_type: j.job_type 
                })));
                
                // If there are completed jobs, auto-fill first one to input box
                if (succeededJobs.length > 0) {
                    const firstJobId = succeededJobs[0].id;
                    document.getElementById('jobIdInput').value = firstJobId;
                    console.log(`Auto-filled Job ID: ${firstJobId}`);
                }
            } else {
                updateStatus(`Server error: ${response.status}`);
                alert(`Server error: ${response.status} ${response.statusText}`);
            }
        } catch (e) {
            updateStatus(`Cannot connect to server`);
            alert(`Cannot connect to server.\n\nError: ${e.message}\n\nPlease check:\n1. Backend server is running: uvicorn app.main:app --reload\n2. Server is accessible at http://127.0.0.1:8000\n3. No firewall blocking the connection`);
            console.error("Connection test failed:", e);
        }
    }
    
    // Close modal with ESC key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeImageModal();
        }
    });
    
    // Real-time verify random Patch
    
    // Show create task modal
    function showCreateTaskModal() {
        const modal = document.getElementById('createTaskModal');
        if (modal) {
            modal.style.display = 'flex';
            // Auto-fill task name based on type
            const taskTypeSelect = document.getElementById('taskTypeSelect');
            const taskNameInput = document.getElementById('taskNameInput');
            if (taskTypeSelect && taskNameInput) {
                const taskType = taskTypeSelect.value;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                if (taskType === 'tissue_mask') {
                    taskNameInput.value = `Tissue_Mask_${timestamp}`;
                } else {
                    taskNameInput.value = `Cell_Segmentation_${timestamp}`;
                }
            }
            // Clear status message
            const statusMsg = document.getElementById('taskStatusMessage');
            if (statusMsg) {
                statusMsg.style.display = 'none';
                statusMsg.textContent = '';
            }
        }
    }
    
    // Close create task modal
    function closeCreateTaskModal() {
        const modal = document.getElementById('createTaskModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }
    
    // Submit task creation
    async function submitTask() {
        const taskTypeSelect = document.getElementById('taskTypeSelect');
        const taskNameInput = document.getElementById('taskNameInput');
        const userIdInput = document.getElementById('userIdInput');
        const statusMsg = document.getElementById('taskStatusMessage');
        
        if (!taskTypeSelect || !taskNameInput) {
            alert('Error: Form elements not found');
            return;
        }
        
        const taskType = taskTypeSelect.value;
        const taskName = taskNameInput.value.trim();
        const userId = userIdInput ? userIdInput.value.trim() : '';
        
        if (!taskName) {
            if (statusMsg) {
                statusMsg.style.display = 'block';
                statusMsg.style.background = '#e74c3c';
                statusMsg.style.color = 'white';
                statusMsg.textContent = 'Please enter a task name';
            }
            return;
        }
        
        // Show loading status
        if (statusMsg) {
            statusMsg.style.display = 'block';
            statusMsg.style.background = '#5c7cfa';
            statusMsg.style.color = 'white';
            statusMsg.textContent = 'Creating task...';
        }
        
        try {
            // Step 1: Create or get user
            let finalUserId = userId;
            if (!finalUserId) {
                // Auto-create user
                const userResponse = await fetch('http://127.0.0.1:8000/users/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        username: `user_${Date.now()}`
                    })
                });
                
                if (!userResponse.ok) {
                    throw new Error(`failed to create user: ${userResponse.statusText}`);
                }
                
                const user = await userResponse.json();
                finalUserId = user.id;
                console.log('Created user:', finalUserId);
            }
            
            // Step 2: Create workflow with job
            const workflowResponse = await fetch('http://127.0.0.1:8000/workflows/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-User-ID': finalUserId
                },
                body: JSON.stringify({
                    jobs: [{
                        name: taskName,
                        job_type: taskType,
                        branch_id: 'main_branch',
                        parent_indices: []
                    }]
                })
            });
            
            if (!workflowResponse.ok) {
                const errorData = await workflowResponse.json();
                throw new Error(errorData.detail || `failed to create workflow: ${workflowResponse.statusText}`);
            }
            
            const workflowResult = await workflowResponse.json();
            console.log('Workflow created:', workflowResult);
            
            // Step 3: Get the job ID from the workflow
            const workflowsResponse = await fetch('http://127.0.0.1:8000/workflows/', {
                headers: {
                    'X-User-ID': finalUserId
                }
            });
            
            if (!workflowsResponse.ok) {
                throw new Error('failed to fetch workflows');
            }
            
            const workflows = await workflowsResponse.json();
            const ourWorkflow = workflows.find(w => w.id === workflowResult.workflow_id);
            
            if (!ourWorkflow || !ourWorkflow.jobs || ourWorkflow.jobs.length === 0) {
                throw new Error('Job not found in workflow');
            }
            
            const jobId = ourWorkflow.jobs[0].id;
            
            // Show success and start polling
            if (statusMsg) {
                statusMsg.style.display = 'block';
                statusMsg.style.background = '#2ecc71';
                statusMsg.style.color = 'white';
                statusMsg.textContent = `Task created! Job ID: ${jobId.substring(0, 8)}... Status: PENDING`;
            }
            
            // Auto-fill job ID and start polling
            document.getElementById('jobIdInput').value = jobId;
            updateStatus(`Task created! Job ID: ${jobId.substring(0, 8)}... Waiting for worker to process...`);
            
            // Start polling job status
            pollJobStatus(jobId);
            
            // Close modal after 2 seconds
            setTimeout(() => {
                closeCreateTaskModal();
            }, 2000);
            
        } catch (error) {
            console.error('Error creating task:', error);
            if (statusMsg) {
                statusMsg.style.display = 'block';
                statusMsg.style.background = '#e74c3c';
                statusMsg.style.color = 'white';
                statusMsg.textContent = `Error: ${error.message}`;
            }
            updateStatus(`failed to create task: ${error.message}`);
        }
    }
    
    // Poll job status until it completes
    let pollingInterval = null;
    function pollJobStatus(jobId) {
        // Clear any existing polling
        if (pollingInterval) {
            clearInterval(pollingInterval);
        }
        
        let pollcount = 0;
        const maxPolls = 300; // 5 minutes max (1 second intervals)
        
        pollingInterval = setInterval(async () => {
            pollcount++;
            
            try {
                const response = await fetch(`http://127.0.0.1:8000/jobs/${jobId}`);
                if (!response.ok) {
                    console.error('failed to poll job status');
                    return;
                }
                
                const job = await response.json();
                const status = job.status;
                
                updateStatus(`Job status: ${status} (polling ${pollcount}/${maxPolls})...`);
                
                if (status === 'SUCCEEDED') {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                    updateStatus(`Job completed! Loading results...`);
                    // Auto-load the job
                    setTimeout(() => {
                        loadDeepZoom();
                    }, 500);
                } else if (status === 'FAILED' || status === 'CANCELLED') {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                    updateStatus(`Job ${status.toLowerCase()}. Check job details for more information.`);
                } else if (pollcount >= maxPolls) {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                    updateStatus(`Polling timeout. Job may still be processing. Status: ${status}`);
                }
            } catch (error) {
                console.error('Error polling job status:', error);
                if (pollcount >= maxPolls) {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                }
            }
        }, 1000); // Poll every second
    }
    
    // Tissue mask overlay functionality
    let tissueMaskLayer = null;
    
    async function toggleTissueMask(btn) {
        // 1. Toggle button state
        const isActive = btn.classList.toggle('active');
        
        if (!viewer) {
            alert('Please load a slide first');
            btn.classList.remove('active');
            return;
        }
        
        // Check whether has tissue_mask job
        if (isActive && currentJobId) {
            try {
                // Check same branch whether has tissue_mask job
                const branchResponse = await fetch(`http://127.0.0.1:8000/jobs/${currentJobId}/branch-jobs`);
                if (branchResponse.ok) {
                    const branchData = await branchResponse.json();
                    if (!branchData.has_tissue_mask) {
                        alert(`No tissue mask job found in this branch.\n\nBranch: ${branchData.branch_id}\ncurrent job type: ${branchData.current_job_type}\n\nPlease run a tissue mask job in this branch first.`);
                        btn.classList.remove('active');
                        return;
                    }
                }
            } catch (e) {
                console.error('Error checking branch jobs:', e);
                // If check failed,continue execution (backward compatible)))
            }
        }
        
        // 2. If closing, remove overlay
        if (!isActive) {
            if (tissueMaskLayer) {
                try {
                    viewer.removeOverlay("tissue-mask-overlay");
                } catch (e) {
                    console.warn("Error removing overlay:", e);
                }
                tissueMaskLayer = null;
            }
            updateStatus("Tissue mask overlay removed");
            return;
        }
        
        // 3. If opening, load mask
        updateStatus("Generating Tissue Mask...");
        btn.disabled = true; // Prevent duplicate clicks
        
        try {
            // Fix: Get original image dimensions(from source,instead of contentSize)
            const tiledImage = viewer.world.getItemAt(0);
            if (!tiledImage) {
                throw new Error("No image loaded");
            }
            
            // Key fix:Use source dimensions,instead of contentSize
            // source.width and source.height are original image pixel dimensions
            const w = tiledImage.source.width;
            const h = tiledImage.source.height;
            
            // Calculate aspect ratio (Aspect Ratio)
            // OpenSeadragon coordinate system:width is fixed to 1,height = h / w
            const aspectRatio = h / w;
            
            console.log(`Image dimensions: ${w}x${h}, aspectRatio: ${aspectRatio}`);
            
            // Create an img element
            const img = document.createElement("img");
            // Pass job_id parameter to use correct image
            img.src = currentJobId 
                ? `http://127.0.0.1:8000/debug/tissue-mask?job_id=${currentJobId}`
                : "http://127.0.0.1:8000/debug/tissue-mask";
            img.id = "tissue-mask-overlay";
            img.style.opacity = "0.6"; // Overall transparency can be adjusted
            
            // Wait for image to load before adding
            img.onload = () => {
                try {
                    // Fix: Get actual loaded mask image dimensions
                    const maskImgWidth = img.naturalWidth;
                    const maskImgHeight = img.naturalHeight;
                    const maskAspectRatio = maskImgHeight / maskImgWidth;
                    
                    console.log(`Mask image dimensions: ${maskImgWidth}x${maskImgHeight}, maskAspectRatio: ${maskAspectRatio}`);
                    console.log(`Image dimensions: ${w}x${h}, imageAspectRatio: ${aspectRatio}`);
                    
                    // Key fix: Use actual aspect ratio of mask image, instead of the image's aspect ratio
                    // This ensures the overlay completely covers the entire image area
                    // OpenSeadragon uses normalized coordinates:x=0, y=0, width=1, height=aspectRatio
                    viewer.addOverlay({
                        element: img,
                        // Use actual aspect ratio of mask image,Ensure overlay completely matches
                        location: new OpenSeadragon.Rect(0, 0, 1, maskAspectRatio)
                    }, "tissue-mask-overlay");
                    
                    // Verify: Check if overlay is correctly covering
                    const overlayBounds = viewer.getOverlayById("tissue-mask-overlay");
                    if (overlayBounds) {
                        console.log(`Overlay bounds:`, overlayBounds);
                    }
                    
                    updateStatus("Tissue Mask Overlay Active");
                    btn.disabled = false;
                    tissueMaskLayer = img;
                } catch (e) {
                    console.error("Error adding overlay:", e);
                    alert("failed to add tissue mask overlay: " + e.message);
                    btn.classList.remove('active');
                    btn.disabled = false;
                }
            };
            
            img.onerror = () => {
                alert("failed to load tissue mask. Please make sure the backend server is running and the image file exists.");
                btn.classList.remove('active');
                btn.disabled = false;
                updateStatus("failed to load tissue mask");
            };
            
        } catch (e) {
            console.error(e);
            updateStatus("Error loading mask: " + e.message);
            btn.classList.remove('active');
            btn.disabled = false;
        }
    }
    
    // ============================================
    // File Manager Functions
    // ============================================
    
    let currentFileManagerUserId = null;
    
    function showFileManagerModal() {
        const modal = document.getElementById('fileManagerModal');
        if (modal) {
            modal.classList.add('active');
            loadFileManagerUsers();
        }
    }
    
    function closeFileManagerModal() {
        const modal = document.getElementById('fileManagerModal');
        if (modal) {
            modal.classList.remove('active');
            currentFileManagerUserId = null;
        }
    }
    
    async function loadFileManagerUsers() {
        try {
            const response = await fetch('http://127.0.0.1:8000/users/');
            if (!response.ok) throw new Error('Failed to load users');
            
            const users = await response.json();
            const selector = document.getElementById('fileManagerUserSelector');
            selector.innerHTML = '<option value="">-- Select a user --</option>';
            
            users.forEach(user => {
                const option = document.createElement('option');
                option.value = user.id;
                option.textContent = `${user.username} (${user.id.substring(0, 8)}...)`;
                selector.appendChild(option);
            });
        } catch (error) {
            console.error('Error loading users:', error);
            updateStatus('Failed to load users');
        }
    }
    
    async function loadUserFiles() {
        const selector = document.getElementById('fileManagerUserSelector');
        const userId = selector.value;
        const userInfoDiv = document.getElementById('selectedUserInfo');
        const userIdDisplay = document.getElementById('selectedUserId');
        
        if (!userId) {
            document.getElementById('fileManagerContent').innerHTML = 
                '<div style="text-align: center; padding: 40px; color: #888;">Please select a user to view their files</div>';
            currentFileManagerUserId = null;
            if (userInfoDiv) userInfoDiv.style.display = 'none';
            return;
        }
        
        currentFileManagerUserId = userId;
        
        // Display user ID
        if (userInfoDiv && userIdDisplay) {
            userIdDisplay.textContent = userId;
            userInfoDiv.style.display = 'block';
        }
        
        try {
            const response = await fetch(`http://127.0.0.1:8000/users/${userId}/files`, {
                headers: {
                    'X-User-ID': userId
                }
            });
            
            if (!response.ok) throw new Error('Failed to load files');
            
            const data = await response.json();
            renderFileManager(data);
        } catch (error) {
            console.error('Error loading files:', error);
            document.getElementById('fileManagerContent').innerHTML = 
                `<div style="text-align: center; padding: 40px; color: #e74c3c;">Failed to load files: ${error.message}</div>`;
        }
    }
    
    function renderFileManager(data) {
        const content = document.getElementById('fileManagerContent');
        
        // Format file size
        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }
        
        // Format date
        function formatDate(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleString();
        }
        
        let html = `
            <div class="file-stats">
                <div class="file-stat-item">
                    <div class="file-stat-value">${data.total_input_files}</div>
                    <div class="file-stat-label">Input Files</div>
                </div>
                <div class="file-stat-item">
                    <div class="file-stat-value">${formatSize(data.total_size_bytes)}</div>
                    <div class="file-stat-label">Total Size</div>
                </div>
            </div>
        `;
        
        // Input files
        html += `
            <div class="file-list-section">
                <div class="file-list-title">Input Files (${data.input_files.length})</div>
        `;
        
        if (data.input_files.length === 0) {
            html += '<div style="padding: 20px; text-align: center; color: #888;">No input files</div>';
        } else {
            data.input_files.forEach(file => {
                html += `
                    <div class="file-item">
                        <div class="file-info">
                            <div class="file-name">${file.filename}</div>
                            <div class="file-meta">
                                ${formatSize(file.size_bytes)} ‚Ä¢ Uploaded: ${formatDate(file.created_at)}
                            </div>
                        </div>
                        <div class="file-actions">
                            <button class="file-action-btn file-action-btn-download" 
                                    onclick="downloadUserFile('${data.user_id}', '${file.filename}', 'input')">
                                Download
                            </button>
                            <button class="file-action-btn file-action-btn-delete" 
                                    onclick="deleteUserFile('${data.user_id}', '${file.filename}', 'input')">
                                Delete
                            </button>
                        </div>
                    </div>
                `;
            });
        }
        
        html += '</div>';
        
        content.innerHTML = html;
    }
    
    async function uploadUserFile() {
        const userId = currentFileManagerUserId;
        if (!userId) {
            alert('Please select a user first');
            return;
        }
        
        const fileInput = document.getElementById('fileUploadInput');
        const file = fileInput.files[0];
        
        if (!file) {
            alert('Please select a file to upload');
            return;
        }
        
        const formData = new FormData();
        formData.append('file', file);
        
        const statusDiv = document.getElementById('uploadStatus');
            statusDiv.innerHTML = 'Uploading...';
        statusDiv.style.color = '#5c7cfa';
        
        try {
            const response = await fetch(`http://127.0.0.1:8000/users/${userId}/files/upload`, {
                method: 'POST',
                headers: {
                    'X-User-ID': userId
                },
                body: formData
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Upload failed');
            }
            
            const result = await response.json();
            statusDiv.innerHTML = `${result.message}: ${result.filename}`;
            statusDiv.style.color = '#2ecc71';
            
            // Clear file input
            fileInput.value = '';
            
            // Refresh file list
            await loadUserFiles();
        } catch (error) {
            statusDiv.innerHTML = `Upload failed: ${error.message}`;
            statusDiv.style.color = '#e74c3c';
        }
    }
    
    async function downloadUserFile(userId, filename, fileType) {
        try {
            const url = `http://127.0.0.1:8000/users/${userId}/files/download?filename=${encodeURIComponent(filename)}&file_type=${fileType}`;
            const response = await fetch(url, {
                headers: {
                    'X-User-ID': userId
                }
            });
            
            if (!response.ok) {
                throw new Error('Download failed');
            }
            
            const blob = await response.blob();
            const downloadUrl = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(downloadUrl);
            
            updateStatus(`Downloaded: ${filename}`);
        } catch (error) {
            console.error('Error downloading file:', error);
            alert(`Failed to download file: ${error.message}`);
        }
    }
    
    async function deleteUserFile(userId, filename, fileType) {
        if (!confirm(`Are you sure you want to delete "${filename}"? This action cannot be undone.`)) {
            return;
        }
        
        try {
            const response = await fetch(`http://127.0.0.1:8000/users/${userId}/files?filename=${encodeURIComponent(filename)}&file_type=${fileType}`, {
                method: 'DELETE',
                headers: {
                    'X-User-ID': userId
                }
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Delete failed');
            }
            
            updateStatus(`Deleted: ${filename}`);
            await loadUserFiles();
        } catch (error) {
            console.error('Error deleting file:', error);
            alert(`Failed to delete file: ${error.message}`);
        }
    }
    
    function refreshFileManager() {
        if (currentFileManagerUserId) {
            loadUserFiles();
        } else {
            loadFileManagerUsers();
        }
    }
    
    async function createNewUser() {
        const usernameInput = document.getElementById('newUserNameInput');
        const statusDiv = document.getElementById('newUserStatus');
        const username = usernameInput.value.trim();
        
        if (!username) {
            statusDiv.innerHTML = 'Please enter a username';
            statusDiv.style.color = '#e74c3c';
            return;
        }
        
        statusDiv.innerHTML = 'Creating user...';
        statusDiv.style.color = '#5c7cfa';
        
        try {
            const response = await fetch('http://127.0.0.1:8000/users/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username: username })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Failed to create user');
            }
            
            const user = await response.json();
            statusDiv.innerHTML = `User created! ID: ${user.id}`;
            statusDiv.style.color = '#2ecc71';
            
            // Clear input
            usernameInput.value = '';
            
            // Refresh user list and select the new user
            await loadFileManagerUsers();
            const selector = document.getElementById('fileManagerUserSelector');
            selector.value = user.id;
            await loadUserFiles();
            
            // Also refresh custom job user list
            await loadUsersForCustomJob();
        } catch (error) {
            statusDiv.innerHTML = `Error: ${error.message}`;
            statusDiv.style.color = '#e74c3c';
        }
    }
    
    async function deleteSelectedUser() {
        const selector = document.getElementById('fileManagerUserSelector');
        const userId = selector.value;
        
        if (!userId) {
            alert('Please select a user first');
            return;
        }
        
        // Get username for confirmation
        const selectedOption = selector.options[selector.selectedIndex];
        const username = selectedOption.textContent.split(' (')[0];
        
        const confirmMsg = `WARNING: This will permanently delete:\n\n` +
            `- User: ${username}\n` +
            `- All workflows and jobs\n` +
            `- All uploaded files\n` +
            `- All output files\n\n` +
            `This action CANNOT be undone!\n\n` +
            `Are you sure you want to delete this user?`;
        
        if (!confirm(confirmMsg)) {
            return;
        }
        
        // Double confirmation
        if (!confirm(`Final confirmation: Delete user "${username}"?\n\nThis is your last chance to cancel.`)) {
            return;
        }
        
        try {
            updateStatus('Deleting user...');
            
            const response = await fetch(`http://127.0.0.1:8000/users/${userId}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Failed to delete user');
            }
            
            const result = await response.json();
            updateStatus(`User deleted: ${result.username} (${result.deleted_workflows} workflows, ${result.deleted_jobs} jobs removed)`);
            
            // Clear selection
            selector.value = '';
            currentFileManagerUserId = null;
            document.getElementById('selectedUserInfo').style.display = 'none';
            document.getElementById('fileManagerContent').innerHTML = 
                '<div style="text-align: center; padding: 40px; color: #888;">Please select a user to view their files</div>';
            
            // Refresh user list
            await loadFileManagerUsers();
        } catch (error) {
            console.error('Error deleting user:', error);
            alert(`Failed to delete user: ${error.message}`);
            updateStatus(`Failed to delete user: ${error.message}`);
        }
    }
    
    function copyUserId() {
        const userIdDisplay = document.getElementById('selectedUserId');
        if (!userIdDisplay) return;
        
        const userId = userIdDisplay.textContent;
        navigator.clipboard.writeText(userId).then(() => {
            updateStatus('User ID copied to clipboard!');
        }).catch(err => {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = userId;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                updateStatus('User ID copied to clipboard!');
            } catch (err) {
                updateStatus('Failed to copy User ID');
            }
            document.body.removeChild(textArea);
        });
    }
    
    // ============================================
    // Test Scheduler Functions
    // ============================================
    
    let testSchedulerPollingInterval = null;
    let testUsers = [];
    let testJobs = [];
    
    function showTestSchedulerModal() {
        const modal = document.getElementById('testSchedulerModal');
        if (modal) {
            modal.classList.add('active');
            loadJobSelector();
            loadUsersForCustomJob();
            renderTestScheduler();
            startTestSchedulerPolling();
        }
    }
    
    async function loadJobSelector() {
        const selector = document.getElementById('jobSelector');
        if (!selector) return;
        
        try {
            const response = await fetch('http://127.0.0.1:8000/debug/jobs');
            if (!response.ok) return;
            
            const jobs = await response.json();
            const succeededJobs = jobs.filter(j => j.status === 'SUCCEEDED').sort((a, b) => 
                new Date(b.created_at) - new Date(a.created_at)
            );
            
            selector.innerHTML = '<option value="">-- Select a completed job --</option>';
            succeededJobs.forEach(job => {
                const option = document.createElement('option');
                option.value = job.id;
                option.textContent = `${job.name || 'Unnamed'} (${job.id.substring(0, 8)}...) - ${job.job_type}`;
                selector.appendChild(option);
            });
        } catch (error) {
            console.error('Error loading job selector:', error);
        }
    }
    
    function loadSelectedJob() {
        const selector = document.getElementById('jobSelector');
        if (!selector || !selector.value) return;
        
        const jobId = selector.value;
        document.getElementById('jobIdInput').value = jobId;
        loadDeepZoom();
    }
    
    async function loadUsersForCustomJob() {
        // This function is kept for compatibility but not used in the new UI
        // Users now enter User ID directly instead of selecting from dropdown
        // The function is called but doesn't need to do anything
        return;
    }
    
    async function onCustomJobUserIdChange() {
        const userIdInput = document.getElementById('customJobUserId');
        if (userIdInput) {
            const userId = userIdInput.value.trim();
            await loadImageFilesForUser(userId);
        }
    }
    
    async function loadImageFilesForUser(userId) {
        const select = document.getElementById('customJobImageFileSelect');
        if (!select || !userId) {
            if (select) {
                select.innerHTML = '<option value="">-- Select from uploaded files (optional) --</option>';
            }
            return;
        }
        
        // Validate UUID format
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        if (!uuidRegex.test(userId)) {
            select.innerHTML = '<option value="">-- Enter valid User ID first --</option>';
            return;
        }
        
        try {
            const response = await fetch(`http://127.0.0.1:8000/users/${userId}/files`, {
                headers: {
                    'X-User-ID': userId
                }
            });
            
            if (!response.ok) {
                select.innerHTML = '<option value="">-- Failed to load files --</option>';
                return;
            }
            
            const data = await response.json();
            select.innerHTML = '<option value="">-- Select from uploaded files (optional) --</option>';
            
            if (data.input_files && data.input_files.length > 0) {
                data.input_files.forEach(file => {
                    const option = document.createElement('option');
                    // Store full path in value
                    const fullPath = `user_files/${userId}/inputs/${file.filename}`;
                    option.value = fullPath;
                    option.textContent = `${file.filename} (${formatFileSize(file.size_bytes)})`;
                    select.appendChild(option);
                });
            } else {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '-- No uploaded files found --';
                option.disabled = true;
                select.appendChild(option);
            }
        } catch (error) {
            console.error('Error loading user files:', error);
            select.innerHTML = '<option value="">-- Error loading files --</option>';
        }
    }
    
    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }
    
    function selectImageFromFileManager() {
        const select = document.getElementById('customJobImageFileSelect');
        const pathInput = document.getElementById('customJobImagePath');
        
        if (select && pathInput && select.value) {
            pathInput.value = select.value;
            // Visual feedback - show selected file
            const selectedOption = select.options[select.selectedIndex];
            if (selectedOption) {
                updateStatus(`Selected file: ${selectedOption.textContent.split(' (')[0]}`);
            }
        } else if (pathInput) {
            pathInput.value = '';
        }
    }
    
    function showCustomJobForm() {
        const form = document.getElementById('customJobForm');
        if (form) {
            form.style.display = 'block';
            loadUsersForCustomJob();
        }
    }
    
    function hideCustomJobForm() {
        const form = document.getElementById('customJobForm');
        if (form) {
            form.style.display = 'none';
        }
    }
    
    async function submitCustomJob() {
        try {
            // Get user ID from input
            const userIdInput = document.getElementById('customJobUserId');
            const userId = userIdInput.value.trim();
            
            if (!userId) {
                alert('Please enter a User ID. You can create a user in File Manager and copy the User ID.');
                return;
            }
            
            // Validate UUID format
            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            if (!uuidRegex.test(userId)) {
                alert('Invalid User ID format. Please enter a valid UUID (e.g., 123e4567-e89b-12d3-a456-426614174000)');
                return;
            }
            
            // Get job parameters
            const branchId = document.getElementById('customJobBranch').value.trim();
            const jobType = document.getElementById('customJobType').value;
            const jobName = document.getElementById('customJobName').value.trim();
            const imagePathInput = document.getElementById('customJobImagePath');
            const imagePath = imagePathInput ? imagePathInput.value.trim() : '';
            
            if (!branchId || !jobName) {
                alert('Please fill in Branch ID and Job Name');
                return;
            }
            
            if (!imagePath) {
                alert('Please select an image file from File Manager');
                return;
            }
            
            // Debug: Log the image path being sent
            console.log('Sending image_path to backend:', imagePath);
            
            // Create workflow with job
            const workflowResponse = await fetch('http://127.0.0.1:8000/workflows/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-User-ID': userId
                },
                body: JSON.stringify({
                    jobs: [{
                        name: jobName,
                        job_type: jobType,
                        branch_id: branchId,
                        parent_indices: [],
                        image_path: imagePath
                    }]
                })
            });
            
            // Debug: Log the request body
            console.log('Request body:', JSON.stringify({
                jobs: [{
                    name: jobName,
                    job_type: jobType,
                    branch_id: branchId,
                    parent_indices: [],
                    image_path: imagePath
                }]
            }, null, 2));
            
            if (workflowResponse.ok) {
                const workflow = await workflowResponse.json();
                updateStatus(`Custom job created! Workflow ID: ${workflow.workflow_id}`);
                hideCustomJobForm();
                renderTestScheduler();
                loadJobSelector();
                
                // Start polling for the new job
                if (workflow.job_count > 0) {
                    // We need to get the job ID from the workflow
                    setTimeout(async () => {
                        const jobsResponse = await fetch('http://127.0.0.1:8000/debug/jobs');
                        if (jobsResponse.ok) {
                            const allJobs = await jobsResponse.json();
                            const newJob = allJobs.find(j => j.workflow_id === workflow.workflow_id);
                            if (newJob) {
                                pollJobStatus(newJob.id);
                            }
                        }
                    }, 1000);
                }
            } else {
                const error = await workflowResponse.text();
                alert(`failed to create job: ${error}`);
            }
        } catch (error) {
            console.error('Error creating custom job:', error);
            alert(`Error: ${error.message}`);
        }
    }
    
    function closeTestSchedulerModal() {
        const modal = document.getElementById('testSchedulerModal');
        if (modal) {
            modal.classList.remove('active');
            stopTestSchedulerPolling();
        }
    }
    
    async function createTestJobs() {
        try {
            updateStatus("Creating test users and jobs...");
            
            const imagePath = "/Users/yiling/Desktop/penn_proj/my-scheduler/data/CMU-1-Small-Region.svs";
            
            // Create 2 test users
            const users = [];
            for (let i = 1; i <= 2; i++) {
                const userResponse = await fetch('http://127.0.0.1:8000/users/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: `test_user_${i}` })
                });
                if (userResponse.ok) {
                    const user = await userResponse.json();
                    users.push(user);
                } else {
                    // User might already exist, try to get it
                    const existingUsers = await fetch('http://127.0.0.1:8000/users/');
                    if (existingUsers.ok) {
                        const allUsers = await existingUsers.json();
                        const existingUser = allUsers.find(u => u.username === `test_user_${i}`);
                        if (existingUser) users.push(existingUser);
                    }
                }
            }
            
            if (users.length === 0) {
                alert("failed to create or find test users");
                return;
            }
            
            testUsers = users;
            
            // test_user_1: branch A (segmentation + tissue mask), branch B (segmentation)
            const user1 = users[0];
            
            // Branch A: segmentation + tissue mask
            const jobsBranchA = [
                {
                    name: "Segmentation_BranchA",
                    job_type: "cell_segmentation",
                    branch_id: "branch_A",
                    parent_indices: [],
                    image_path: imagePath
                },
                {
                    name: "TissueMask_BranchA",
                    job_type: "tissue_mask",
                    branch_id: "branch_A",
                    parent_indices: [],
                    image_path: imagePath
                }
            ];
            
            const workflowResponseA = await fetch('http://127.0.0.1:8000/workflows/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-User-ID': user1.id
                },
                body: JSON.stringify({ jobs: jobsBranchA })
            });
            
            if (workflowResponseA.ok) {
                const workflow = await workflowResponseA.json();
                console.log(`Created workflow for user ${user1.username} branch A:`, workflow);
            } else {
                const error = await workflowResponseA.text();
                console.error(`failed to create workflow for user ${user1.username} branch A:`, error);
            }
            
            // Branch B: segmentation
            const jobsBranchB = [
                {
                    name: "Segmentation_BranchB",
                    job_type: "cell_segmentation",
                    branch_id: "branch_B",
                    parent_indices: [],
                    image_path: imagePath
                }
            ];
            
            const workflowResponseB = await fetch('http://127.0.0.1:8000/workflows/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-User-ID': user1.id
                },
                body: JSON.stringify({ jobs: jobsBranchB })
            });
            
            if (workflowResponseB.ok) {
                const workflow = await workflowResponseB.json();
                console.log(`Created workflow for user ${user1.username} branch B:`, workflow);
            } else {
                const error = await workflowResponseB.text();
                console.error(`failed to create workflow for user ${user1.username} branch B:`, error);
            }
            
            // test_user_2: branch A (tissue mask)
            const user2 = users[1];
            
            const jobsUser2BranchA = [
                {
                    name: "TissueMask_BranchA",
                    job_type: "tissue_mask",
                    branch_id: "branch_A",
                    parent_indices: [],
                    image_path: imagePath
                }
            ];
            
            const workflowResponseUser2 = await fetch('http://127.0.0.1:8000/workflows/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-User-ID': user2.id
                },
                body: JSON.stringify({ jobs: jobsUser2BranchA })
            });
            
            if (workflowResponseUser2.ok) {
                const workflow = await workflowResponseUser2.json();
                console.log(`Created workflow for user ${user2.username} branch A:`, workflow);
            } else {
                const error = await workflowResponseUser2.text();
                console.error(`failed to create workflow for user ${user2.username} branch A:`, error);
            }
            
            updateStatus("Test jobs created! refreshing...");
            setTimeout(() => {
                renderTestScheduler();
                loadJobSelector();
            }, 1000);
            
        } catch (error) {
            console.error("Error creating test jobs:", error);
            alert(`Error creating test jobs: ${error.message}`);
        }
    }
    
    async function renderTestScheduler() {
        const container = document.getElementById('testSchedulerUsersContainer');
        if (!container) return;
        
        try {
            // Fetch all users
            const usersResponse = await fetch('http://127.0.0.1:8000/users/');
            if (!usersResponse.ok) {
                container.innerHTML = '<div style="color: #e74c3c;">failed to fetch users</div>';
                return;
            }
            
            const allUsers = await usersResponse.json();
            // Show all users, not just test users
            const usersList = allUsers.length > 0 ? allUsers : [];
            
            if (usersList.length === 0) {
                container.innerHTML = '<div style="color: #888; text-align: center; padding: 40px;">No users found. Click "Create Custom Job" or "Create Test Jobs" to create users and jobs.</div>';
                return;
            }
            
            // Fetch all workflows to map jobs to users
            const workflowsResponse = await fetch('http://127.0.0.1:8000/workflows/');
            if (!workflowsResponse.ok) {
                container.innerHTML = '<div style="color: #e74c3c;">failed to fetch workflows</div>';
                return;
            }
            
            const allWorkflows = await workflowsResponse.json();
            
            // Fetch all jobs (including all statuses to show complete picture)
            const jobsResponse = await fetch('http://127.0.0.1:8000/debug/jobs');
            if (!jobsResponse.ok) {
                container.innerHTML = '<div style="color: #e74c3c;">failed to fetch jobs</div>';
                return;
            }
            
            const allJobs = await jobsResponse.json();
            
            // Debug information: Display status statistics for all tasks
            const statuscounts = {};
            allJobs.forEach(job => {
                statuscounts[job.status] = (statuscounts[job.status] || 0) + 1;
            });
            console.log("Job status counts:", statuscounts);
            if (statuscounts['PENDING'] > 0 || statuscounts['QUEUED'] > 0 || statuscounts['RUNNING'] > 0) {
                console.log(`Warning: ${(statuscounts['PENDING'] || 0) + (statuscounts['QUEUED'] || 0) + (statuscounts['RUNNING'] || 0)} active jobs found`);
            }
            
            // Create a map: workflow_id -> user_id
            const workflowToUser = {};
            allWorkflows.forEach(wf => {
                workflowToUser[wf.id] = wf.user_id;
            });
            
            // Create a map: user_id -> jobs
            const userToJobs = {};
            usersList.forEach(user => {
                userToJobs[user.id] = [];
            });
            
            allJobs.forEach(job => {
                const userId = workflowToUser[job.workflow_id];
                if (userId && userToJobs[userId]) {
                    userToJobs[userId].push(job);
                }
            });
            
            // Render users and their jobs
            container.innerHTML = usersList.map((user, userIndex) => {
                const userJobs = (userToJobs[user.id] || []).sort((a, b) => a.name.localeCompare(b.name));
                // Show user ID to distinguish users with same name
                const userIdShort = user.id.substring(0, 8);
                
                return `
                    <div class="user-section">
                        <div class="user-header">${user.username} <span style="color: #888; font-size: 12px;">(${userIdShort}...)</span></div>
                        <div class="jobs-list">
                            ${userJobs.length > 0 ? userJobs.map(job => renderJobCard(job, user.id)).join('') : 
                                '<div style="color: #888; text-align: center; padding: 20px;">No jobs found</div>'}
                        </div>
                    </div>
                `;
            }).join('');
            
            // update job selector
            loadJobSelector();
            
        } catch (error) {
            console.error("Error rendering test scheduler:", error);
            container.innerHTML = `<div style="color: #e74c3c;">Error: ${error.message}</div>`;
        }
    }
    
    function renderJobCard(job, userId) {
        const jobIdShort = job.id.substring(0, 8);
        const progress = job.total_tiles > 0 ? (job.processed_tiles / job.total_tiles * 100) : 0;
        const canCancel = ['PENDING', 'QUEUED', 'RUNNING'].includes(job.status);
        const logId = `job-log-${job.id}`;
        const toggleId = `job-log-toggle-${job.id}`;
        
        // Check if this log should be open (from persistent set)
        const isLogOpen = openLogsSet.has(job.id);
        const logActiveClass = isLogOpen ? 'active' : '';
            const toggleText = isLogOpen ? 'Hide Log' : 'Show Log';
        const toggleActiveClass = isLogOpen ? 'active' : '';
        
        // Generate log content based on job status and progress
        let logContent = generateJobLog(job);
        
        return `
            <div class="job-card" id="job-card-${job.id}">
                <div class="job-card-header">
                    <div>
                        <div class="job-id">${jobIdShort}</div>
                        <div class="job-branch">${job.branch_id || 'N/A'}</div>
                    </div>
                    <span class="job-status ${job.status}">${job.status}</span>
                </div>
                <div class="job-progress">
                    <div class="job-progress-text">${job.processed_tiles || 0} / ${job.total_tiles || 0}</div>
                    <div class="job-progress-bar">
                        <div class="job-progress-fill" style="width: ${progress}%"></div>
                    </div>
                </div>
                <button class="job-log-toggle ${toggleActiveClass}" id="${toggleId}" onclick="toggleJobLog('${job.id}')">
                    ${toggleText}
                </button>
                <div class="job-log ${logActiveClass}" id="${logId}">
                    ${logContent}
                </div>
                <div class="job-actions">
                    ${job.status === 'SUCCEEDED' && job.job_type === 'cell_segmentation' ? `
                        <div class="job-export-btn-group">
                            <button class="job-export-btn" onclick="downloadJobExport('${job.id}', 'zarr')" title="Download Zarr">
                                Zarr
                            </button>
                            <button class="job-export-btn" onclick="downloadJobExport('${job.id}', 'csv')" title="Download CSV">
                                CSV
                            </button>
                        </div>
                    ` : ''}
                    <button class="job-cancel-btn" onclick="cancelTestJob('${job.id}', '${userId}')" 
                            ${!canCancel ? 'disabled' : ''}>
                        Cancel
                    </button>
                </div>
            </div>
        `;
    }
    
    function generateJobLog(job) {
        let logLines = [];
        
        // Job info
        logLines.push(`<div class="job-log-line info">Worker processing job: ${job.name || 'Unnamed'}</div>`);
        logLines.push(`<div class="job-log-line info">Job ID: ${job.id.substring(0, 8)}...</div>`);
        
        if (job.total_tiles > 0) {
            logLines.push(`<div class="job-log-line info">Processing ${job.total_tiles} tiles</div>`);
            logLines.push(`<div class="job-log-line info">Job Type: ${job.job_type || 'N/A'}</div>`);
        }
        
        // Progress info
        if (job.status === 'RUNNING' && job.total_tiles > 0) {
            const progressPercent = ((job.processed_tiles || 0) / job.total_tiles * 100).toFixed(1);
            logLines.push(`<div class="job-log-line info">Progress: ${job.processed_tiles || 0}/${job.total_tiles} (${progressPercent}%)</div>`);
        }
        
        // Result info (if completed)
        if (job.status === 'SUCCEEDED' && job.result_metadata) {
            try {
                const result = JSON.parse(job.result_metadata);
                if (result.total_cells !== undefined) {
                    logLines.push(`<div class="job-log-line success">Cell segmentation completed! Detected ${result.total_cells} cells</div>`);
                    if (result.pixel_size) {
                        logLines.push(`<div class="job-log-line info">Pixel Size: ${result.pixel_size} Œºm/pixel</div>`);
                    }
                    if (result.skipped_background !== undefined) {
                        const skipPercent = result.total_tiles > 0 ? (result.skipped_background / result.total_tiles * 100).toFixed(1) : 0;
                        logLines.push(`<div class="job-log-line info">Performance optimization: Skipped ${result.skipped_background} background tiles (saved ${skipPercent}% processing time)</div>`);
                    }
                }
                if (result.tissue_tiles !== undefined) {
                    logLines.push(`<div class="job-log-line success">Tissue mask generated!</div>`);
                    logLines.push(`<div class="job-log-line info">Tissue tiles: ${result.tissue_tiles}</div>`);
                    logLines.push(`<div class="job-log-line info">Background tiles: ${result.background_tiles || 0}</div>`);
                    if (result.tissue_ratio) {
                        logLines.push(`<div class="job-log-line info">Tissue ratio: ${(result.tissue_ratio * 100).toFixed(1)}%</div>`);
                    }
                    if (result.skipped_background !== undefined) {
                        const skipPercent = result.total_tiles > 0 ? (result.skipped_background / result.total_tiles * 100).toFixed(1) : 0;
                        logLines.push(`<div class="job-log-line info">Fast skip background: ${result.skipped_background} (saved ${skipPercent}% processing time)</div>`);
                    }
                }
            } catch (e) {
                // Ignore parse errors
            }
        }
        
        // Error info
        if (job.status === 'FAILED' && job.error) {
            logLines.push(`<div class="job-log-line error">Error: ${job.error}</div>`);
        }
        
        // Status
        if (job.status === 'PENDING') {
            logLines.push(`<div class="job-log-line warning">Waiting to be scheduled...</div>`);
        } else if (job.status === 'QUEUED') {
            logLines.push(`<div class="job-log-line warning">Queued, waiting for worker...</div>`);
        } else if (job.status === 'CANCELLED') {
            logLines.push(`<div class="job-log-line warning">Job cancelled</div>`);
        }
        
        return logLines.join('');
    }
    
    function toggleJobLog(jobId) {
        // Toggle log visibility: click once to open, click again to close
        const logId = `job-log-${jobId}`;
        const toggleId = `job-log-toggle-${jobId}`;
        const log = document.getElementById(logId);
        const toggle = document.getElementById(toggleId);
        
        if (log && toggle) {
            // Toggle the 'active' class to show/hide the log
            const isActive = log.classList.toggle('active');
            
            // update persistent set to remember which logs are open
            if (isActive) {
                openLogsSet.add(jobId);
            } else {
                openLogsSet.delete(jobId);
            }
            
            // update button text based on state
            toggle.textContent = isActive ? 'Hide Log' : 'Show Log';
            toggle.classList.toggle('active', isActive);
            
            // Auto-scroll to bottom when opening
            if (isActive) {
                setTimeout(() => {
                    log.scrollTop = log.scrollHeight;
                }, 100);
            }
        }
    }
    
    async function cancelTestJob(jobId, userId) {
        if (!confirm('Are you sure you want to cancel this job?')) return;
        
        try {
            const response = await fetch(`http://127.0.0.1:8000/jobs/${jobId}/cancel`, {
                method: 'POST',
                headers: {
                    'X-User-ID': userId
                }
            });
            
            if (response.ok) {
                updateStatus("Job cancelled successfully");
                renderTestScheduler();
            } else {
                const error = await response.text();
                alert(`failed to cancel job: ${error}`);
            }
        } catch (error) {
            console.error("Error cancelling job:", error);
            alert(`Error cancelling job: ${error.message}`);
        }
    }
    
    async function cancelAllTestJobs() {
        if (!confirm('Are you sure you want to cancel all running/queued jobs? This will stop all PENDING, QUEUED, and RUNNING jobs across ALL users.')) return;
        
        try {
            updateStatus("Cancelling all jobs...");
            const response = await fetch('http://127.0.0.1:8000/debug/cancel-all-jobs', {
                method: 'POST'
            });
            
            if (response.ok) {
                const data = await response.json();
                const message = `${data.message}`;
                if (data.cancelled_jobs && data.cancelled_jobs.length > 0) {
                    const jobsList = data.cancelled_jobs.slice(0, 5).map(j => 
                        `${j.name} (${j.branch}): ${j.old_status}`
                    ).join(', ');
                    const moreText = data.cancelled_count > 5 ? ` ... and ${data.cancelled_count - 5} more` : '';
                    updateStatus(`${message}\nCancelled: ${jobsList}${moreText}`);
                } else {
                    updateStatus(message);
                }
                // Fix: Immediately refresh display and force clear cache
                console.log(`Cancelled ${data.cancelled_count} jobs`);
                // Immediately refresh, do not wait
                renderTestScheduler();
                // Refresh again to ensure status update (Scheduler may still be running)
                setTimeout(() => {
                    renderTestScheduler();
                }, 1000);
                setTimeout(() => {
                    renderTestScheduler();
                }, 3000);
            } else {
                const error = await response.text();
                alert(`failed to cancel jobs: ${error}`);
                updateStatus(`failed to cancel jobs: ${error}`);
            }
        } catch (error) {
            console.error("Error cancelling jobs:", error);
            alert(`Error cancelling jobs: ${error.message}`);
            updateStatus(`Error: ${error.message}`);
        }
    }
    
    async function downloadJobExport(jobId, format) {
        try {
            const url = `http://127.0.0.1:8000/jobs/${jobId}/export?format=${format}`;
            const response = await fetch(url);
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Export failed: ${response.status} - ${errorText}`);
            }
            
            // Get filename from Content-Disposition header or use default
            const contentDisposition = response.headers.get('Content-Disposition');
            let filename = format === 'zarr' 
                ? `cell_segmentation_${jobId.substring(0, 8)}.zarr.zip`
                : `cell_segmentation_${jobId.substring(0, 8)}.${format}`;
            if (contentDisposition) {
                const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/);
                if (filenameMatch) {
                    filename = filenameMatch[1];
                }
            }
            
            // Get file content
            const blob = await response.blob();
            
            // Create download link
            const downloadUrl = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(downloadUrl);
            
            // Show success message
            updateStatus(`Exported ${format.toUpperCase()} file: ${filename}`);
            console.log(`Downloaded ${format.toUpperCase()} export for job ${jobId.substring(0, 8)}`);
            
        } catch (error) {
            console.error("Error downloading export:", error);
            alert(`Failed to download export: ${error.message}`);
            updateStatus(`Export failed: ${error.message}`);
        }
    }
    
    async function clearAllTestJobs() {
        if (!confirm('Are you sure you want to clear all test jobs? This will delete all jobs and workflows.')) return;
        
        try {
            const response = await fetch('http://127.0.0.1:8000/debug/clear-all-jobs?clear_files=false', {
                method: 'POST'
            });
            
            if (response.ok) {
                updateStatus("All jobs cleared");
                renderTestScheduler();
                loadJobSelector();
            } else {
                const error = await response.text();
                alert(`failed to clear jobs: ${error}`);
            }
        } catch (error) {
            console.error("Error clearing jobs:", error);
            alert(`Error clearing jobs: ${error.message}`);
        }
    }
    
    // Store which logs should be open (persistent across re-renders)
    const openLogsSet = new Set();
    
    function startTestSchedulerPolling() {
        if (testSchedulerPollingInterval) return;
        
        testSchedulerPollingInterval = setInterval(() => {
            const modal = document.getElementById('testSchedulerModal');
            if (modal && modal.classList.contains('active')) {
                // Preserve log toggle states - update the persistent set
                document.querySelectorAll('.job-log.active').forEach(log => {
                    const jobId = log.id.replace('job-log-', '');
                    openLogsSet.add(jobId);
                });
                
                renderTestScheduler();
                
                // Restore log toggle states after DOM is updated
                // Use multiple attempts to ensure DOM is ready
                const restoreLogs = () => {
                    openLogsSet.forEach(jobId => {
                        const log = document.getElementById(`job-log-${jobId}`);
                        const toggle = document.getElementById(`job-log-toggle-${jobId}`);
                        if (log && toggle) {
                            log.classList.add('active');
                            toggle.textContent = 'Hide Log';
                            toggle.classList.add('active');
                            // Scroll to bottom
                            setTimeout(() => {
                                log.scrollTop = log.scrollHeight;
                            }, 50);
                        }
                    });
                };
                
                // Try to restore immediately
                restoreLogs();
                
                // Also try after a short delay to ensure DOM is fully updated
                setTimeout(restoreLogs, 100);
                setTimeout(restoreLogs, 300);
                
                loadJobSelector(); // Also update job selector
            } else {
                stopTestSchedulerPolling();
            }
        }, 2000); // Poll every 2 seconds
    }
    
    function stopTestSchedulerPolling() {
        if (testSchedulerPollingInterval) {
            clearInterval(testSchedulerPollingInterval);
            testSchedulerPollingInterval = null;
        }
    }
    
    // Close modal when clicking outside
    document.addEventListener('click', (e) => {
        const modal = document.getElementById('testSchedulerModal');
        if (modal && e.target === modal) {
            closeTestSchedulerModal();
        }
    });
    
    // Check server connection on page load
    window.addEventListener('load', () => {
        console.log("Page loaded. Open browser console (F12) to see debug messages.");
        console.log("To test connection, click the 'Test' button or call testConnection() in console.");
    });
</script>
</body>
</html>
